%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.11.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockSent
    %define! Description_%@LDD_I2C@OnMasterBlockSent This event is called when I2C in master mode finishes the transmission of the data successfully. This event is not available for the SLAVE mode and if MasterSendBlock is disabled.  The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockSent
%endif %- LDD_I2C
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockReceived
    %define! Description_%@LDD_I2C@OnMasterBlockReceived This event is called when I2C is in master mode and finishes the reception of the data successfully. This event is not available for the SLAVE mode and if MasterReceiveBlock is disabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockReceived
%endif %- LDD_I2C
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_TTIME
#define __BWUserType_%'ModuleName'_TTIME
  typedef struct {                                               %>40/* Time in binary format */
    byte hour;                                                   %>40/* hours */
    byte min;                                                    %>40/* minutes */
    byte sec;                                                    %>40/* seconds */
    bool mode;                                                   %>40/* clock mode, 0 for 12-hour mode, otherwise 0-24 hour mode */
    byte am_pm;                                                  %>40/* 0: AM, otherwise PM */
  } %'ModuleName'_TTIME;
#endif
#ifndef __BWUserType_%'ModuleName'_TDATE
#define __BWUserType_%'ModuleName'_TDATE
  typedef struct {                                               %>40/* Date in binary format */
    byte year;                                                   %>40/* year */
    byte month;                                                  %>40/* month */
    byte day;                                                    %>40/* day */
    bool dayOfWeek;                                              %>40/* Day of week, where 0 is the first day. In the range of 0..6 */
  } %'ModuleName'_TDATE;
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
#define %'ModuleName'%.WRITE_BUFFER_SIZE %WriteBufferSize /* size of internal buffer used, set in the component properties */

typedef enum %'ModuleName'_EnumSendFlags_ {
  %'ModuleName'_SEND_STOP,        /* STOP is sent */
  %'ModuleName'_DO_NOT_SEND_STOP, /* STOP is not sent */
  %'ModuleName'_STOP_NOSTART      /* send STOP without START condition */
} %'ModuleName'_EnumSendFlags;

typedef enum %'ModuleName'_EnumStartFlags_ {
  %'ModuleName'_SEND_START,        /* Start is sent */
  %'ModuleName'_DO_NOT_SEND_START, /* Start is not sent */
} %'ModuleName'_EnumStartFlags;

typedef enum %'ModuleName'_EnumAckFlags_ {
  %'ModuleName'_SEND_LAST_ACK,   /* Nack after last received byte is sent */
  %'ModuleName'_DO_NOT_LAST_ACK, /* Nack after last received byte is not sent */
} %'ModuleName'_EnumAckFlags;

%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GenericI2CInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\GenericI2CDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
byte %'ModuleName'%.%ReadAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
byte %'ModuleName'%.%WriteAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
byte %'ModuleName'%.%ReadBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
byte %'ModuleName'%.%WriteBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
void %'ModuleName'%.%RequestBus(void);
%include Common\GenericI2CRequestBus.Inc

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
void %'ModuleName'%.%ReleaseBus(void);
%include Common\GenericI2CReleaseBus.Inc

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
byte %'ModuleName'%.%SelectSlave(byte i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
byte %'ModuleName'%.%UnselectSlave(void);
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
byte %'ModuleName'%.%ReadByteAddress8(byte i2cAddr, byte memAddr, byte *data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
byte %'ModuleName'%.%WriteByteAddress8(byte i2cAddr, byte memAddr, byte data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
byte %'ModuleName'%.%ScanDevice(byte i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
byte %'ModuleName'%.%ProbeACK(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, word WaitTimeUS);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlockGeneric
%ifdef ReadBlockGeneric
byte %'ModuleName'%.%ReadBlockGeneric(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, %'ModuleName'_EnumStartFlags flagsStart, %'ModuleName'_EnumAckFlags flagsAck);
%define! Pardata
%define! PardataSize
%define! ParflagsSend
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericI2CReadBlockGeneric.Inc

%endif %- ReadBlockGeneric
%-BW_METHOD_END ReadBlockGeneric
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnMasterBlockSent
%ifdef OnMasterBlockSent
%INTERFACE OnMasterBlockSent
void %OnMasterBlockSent(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockSent.Inc

%endif %- OnMasterBlockSent
%-BW_METHOD_END OnMasterBlockSent
%-BW_METHOD_BEGIN OnMasterBlockReceived
%ifdef OnMasterBlockReceived
%INTERFACE OnMasterBlockReceived
void %OnMasterBlockReceived(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockReceived.Inc

%endif %- OnMasterBlockReceived
%-BW_METHOD_END OnMasterBlockReceived
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%INTERFACE OnRequestBus
void %OnRequestBus(void);
%include Common\GenericI2COnRequestBus.Inc

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%INTERFACE OnReleaseBus
void %OnReleaseBus(void);
%include Common\GenericI2COnReleaseBus.Inc

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(void);
%include Common\GenericI2COnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#ifndef NULL
  #define NULL 0L
#endif /* NULL */
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if defined(LDD_I2C)
typedef struct {
  volatile bool dataReceivedFlg; /* set to TRUE by the interrupt if we have received data */
  volatile bool dataTransmittedFlg; /* set to TRUE by the interrupt if we have set data */
  LDD_TDeviceData *handle; /* pointer to the device handle */
} %'ModuleName'%.TDataState;

static %'ModuleName'%.TDataState %'ModuleName'%.deviceData;

%if defined(Timeout)
#define %'ModuleName'%.TIMEOUT_US  ((uint32_t)%TimeoutUs)  /* number of microseconds as specified in properties */
#define %'ModuleName'%.TIMEOUT_NOF_TICKS(factor) ((%'ModuleName'%.TIMEOUT_US*(factor))/1000/%@Timeout@'ModuleName'%.TICK_PERIOD_MS)
#define %'ModuleName'%.TIMEOUT_TICKS(factor) (%'ModuleName'%.TIMEOUT_NOF_TICKS(factor)>0?%'ModuleName'%.TIMEOUT_NOF_TICKS(factor):1)  /* at least one tick */
%endif
%endif
%if defined(RTOS) & %UseSemaphore='yes'
static xSemaphoreHandle %'ModuleName'%.busSem = NULL; /* Semaphore to protect I2C bus access */
%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
%include Common\GenericI2CRequestBus.Inc
void %'ModuleName'%.%RequestBus(void)
{
  /*lint -save -e522 function lacks side effect  */
%if defined(OnRequestBus)
  %OnRequestBus();
%endif
  /*lint -restore */
%if defined(RTOS) & %UseSemaphore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(%'ModuleName'%.busSem, portMAX_DELAY);
%endif
}

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
%include Common\GenericI2CReleaseBus.Inc
void %'ModuleName'%.%ReleaseBus(void)
{
%if defined(RTOS) & %UseSemaphore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(%'ModuleName'%.busSem);
%endif
  /*lint -save -e522 function lacks side effect  */
%if defined(OnReleaseBus)
  %OnReleaseBus();
%endif
  /*lint -restore */
}

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc
byte %'ModuleName'%.%SelectSlave(byte i2cAddr)
{
%if (defined(OnRequestBus)) | (defined(RTOS) & %UseSemaphore='yes')
  %'ModuleName'%.%RequestBus();
%endif
%if defined(LDD_I2C)
  if (%@LDD_I2C@'ModuleName'%.SelectSlaveDevice(%'ModuleName'%.deviceData.handle, LDD_I2C_ADDRTYPE_7BITS, i2cAddr)!=ERR_OK) {
  %if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
    %'ModuleName'%.%ReleaseBus();
  %endif
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
%endif
%if defined(I2C)
  if (%@I2C@'ModuleName'%.SelectSlave(i2cAddr)!=ERR_OK) {
  %if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
    %'ModuleName'%.%ReleaseBus();
  %endif
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
%endif
  return ERR_OK;
}

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc
byte %'ModuleName'%.%UnselectSlave(void)
{
%if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
  %'ModuleName'%.%ReleaseBus();
%endif
  return ERR_OK;
}

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlockGeneric
%ifdef ReadBlockGeneric
%define! Pardata
%define! PardataSize
%define! ParflagsSend
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericI2CReadBlockGeneric.Inc
byte %'ModuleName'%.%ReadBlockGeneric(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, %'ModuleName'_EnumStartFlags flagsStart, %'ModuleName'_EnumAckFlags flagsAck)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  word nof;
%endif

%if defined(LDD_I2C)
  #warning "functionality not implemented yet for I2C LDD. Disable this function to disable warning."
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlockCustom(data, dataSize, &nof, flagsStart, flagsAck);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ReadBlockGeneric
%-BW_METHOD_END ReadBlockGeneric
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc
byte %'ModuleName'%.%ReadBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  word nof;
%endif

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc
byte %'ModuleName'%.%WriteBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags)
{
%if defined(I2C)
  word nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  byte res = ERR_OK;

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
%if %SupportStopNoStart='yes'
    if (%'ModuleName'_STOP_NOSTART==flags) {
      res = %@I2C@'ModuleName'%.SendBlockContinue(data, dataSize, &nof);
    } else {
      res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    }
%else
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
%endif
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP || (flags==%'ModuleName'_STOP_NOSTART)) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc
byte %'ModuleName'%.%ReadAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  word nof;
%endif

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address and memory address */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, memAddr, memAddrSize, LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(memAddrSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    /* receive data */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock((void*)memAddr, memAddrSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc
byte %'ModuleName'%.%WriteAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize)
{
  static byte writeBuf[%'ModuleName'%.WRITE_BUFFER_SIZE];
  byte *p;
  word i;
%if defined(I2C)
  word nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  byte res = ERR_OK;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
  if (memAddrSize+dataSize>%'ModuleName'%.WRITE_BUFFER_SIZE) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
  i = 0; p = memAddr;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && memAddrSize>0) {
    writeBuf[i++] = *p++;
    memAddrSize--;
  }
  p = data;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && dataSize>0) {
    writeBuf[i++] = *p++;
    dataSize--;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address, memory address and data */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    if (%@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, writeBuf, i, LDD_I2C_SEND_STOP)!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(i)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock((void*)writeBuf, i, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
%include Common\GeneralInternal.inc (OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataTransmittedFlg = TRUE;
%ifdef OnMasterBlockSent
  } else { /* call user or inherited component event */
    %OnMasterBlockSent(UserDataPtr);
%endif %- OnMasterBlockSent
  }
}

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
%include Common\GeneralInternal.inc (OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataReceivedFlg = TRUE;
%ifdef OnMasterBlockReceived
  } else { /* call user or inherited component event */
    %OnMasterBlockReceived(UserDataPtr);
%endif %- OnMasterBlockReceived
  }
}

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GenericI2CInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.handle = %@LDD_I2C@'ModuleName'%.Init(&%'ModuleName'%.deviceData);
  if (%'ModuleName'%.deviceData.handle==NULL) {
  %if defined(OnError)
    %OnError();
  %endif
    for(;;){} /* failure! */
  }
%endif
%if defined(RTOS) & %UseSemaphore='yes'
  %'ModuleName'%.busSem = %@RTOS@'ModuleName'%.xSemaphoreCreateRecursiveMutex();
  if (%'ModuleName'%.busSem==NULL) { /* semaphore creation failed */
  %if defined(OnError)
    %OnError();
  %endif
    for(;;) {} /* error, not enough memory? */
  }
%endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\GenericI2CDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(LDD_I2C)
  %@LDD_I2C@'ModuleName'%.Deinit(&%'ModuleName'%.deviceData);
%endif
%if defined(RTOS) & %UseSemaphore='yes'
  %@RTOS@'ModuleName'%.vSemaphoreDelete(%'ModuleName'%.busSem);
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
%if defined(RTOS) & %UseSemaphore='yes'
  return %'ModuleName'%.busSem;
%else
  return NULL; /* RTOS and Semaphore enabled in properties */
%endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc
byte %'ModuleName'%.%ReadByteAddress8(byte i2cAddr, byte memAddr, byte *data)
{
  return %'ModuleName'%.ReadAddress(i2cAddr, &memAddr, sizeof(memAddr), data, 1);
}

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc
byte %'ModuleName'%.%WriteByteAddress8(byte i2cAddr, byte memAddr, byte data)
{
  return %'ModuleName'%.WriteAddress(i2cAddr, &memAddr, sizeof(memAddr), &data, 1);
}

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc
byte %'ModuleName'%.%ScanDevice(byte i2cAddr)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  LDD_I2C_TErrorMask errMask;
%else
  word nof;
%endif
  byte dummy;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, &dummy, 1, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(1)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
    errMask = 0;
    (void)%@LDD_I2C@'ModuleName'%.GetError(%'ModuleName'%.deviceData.handle, &errMask);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
%endif
    if (errMask&LDD_I2C_MASTER_NACK) { /* master did not receive ACK from slave */
      res = ERR_NOTAVAIL; /* device did not respond with ACK */
    %if defined(OnError)
      %OnError();
    %endif
    }
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock((void*)&dummy, 1, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
    %if defined(OnError)
      %OnError();
    %endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc
byte %'ModuleName'%.%ProbeACK(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, word WaitTimeUS)
{
%if defined(I2C)
  word nof;
%endif
  byte res = ERR_OK;

%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
  res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
  if (res!=ERR_OK) {
  %if defined(OnError)
    %OnError();
  %endif
    return res;
  }
  /*lint -save -e522 Lacks side effect */
  %@Wait@'ModuleName'%.Waitus(WaitTimeUS);
  /*lint -restore */
  if (!%'ModuleName'%.deviceData.dataTransmittedFlg) {
  %if defined(OnError)
    %OnError();
  %endif
    return ERR_FAILED; /* no ACK received? */
  }
%else
  (void)WaitTimeUS; /* not used */
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    %if defined(OnError)
      %OnError();
    %endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      %if defined(OnError)
        %OnError();
      %endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%IMPLEMENTATION OnRequestBus
%include Common\GenericI2COnRequestBus.Inc
void %OnRequestBus(void)
{
  /* Write your code here ... */
}

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%IMPLEMENTATION OnReleaseBus
%include Common\GenericI2COnReleaseBus.Inc
void %OnReleaseBus(void)
{
  /* Write your code here ... */
}

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%include Common\GenericI2COnError.Inc
void %OnError(void)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if %initOnStartup='yes'
  %'ModuleName'%.%Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
