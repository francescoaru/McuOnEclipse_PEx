%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for losing or damaging your code!
%-
%-
%- readyINTERFACE Bit_IO
%- readyINTERFACE Bit_IO_In
%- readyCOMPILER COSMIC 68HC08 C Compiler V4.2c
%- readyCOMPILER Metrowerks HC08 C Compiler
%- readyCOMPILER Metrowerks HCS08 C Compiler
%- readyCOMPILER Metrowerks HC12 C Compiler
%- readyCOMPILER Metrowerks DSP C Compiler
%- readyCOMPILER FFMC16 C-Compiler V30
%- readyCOMPILER CodeWarrior HC12X C Compiler
%- readyCOMPILER CodeWarrior ColdFireV1 C Compiler
%- readyCOMPILER CodeWarrior RS08 C Compiler
%-
%apploc revDate 06.06.2007
%apploc revVer  01.15
%apploc revLvl  5
%apploc revAuth MS
%apploc revVrf  RH
%apploc revCmnt_14 RS08 compiler support added
%-
%apploc revDate 27.02.2007
%apploc revVer  01.14
%apploc revLvl  5
%apploc revAuth MS
%apploc revVrf  RH
%apploc revCmnt_13 CFV1 compiler support added
%-
%apploc revDate 28.11.2005
%apploc revVer  01.13
%apploc revLvl  5
%apploc revAuth MS
%apploc revVrf  RH
%apploc revCmnt_12 MISRA compliance improved
%-
%apploc revDate 17.11.2005
%apploc revVer  01.12
%apploc revLvl  5
%apploc revAuth MS
%apploc revVrf  RH
%apploc revCmnt_11 HCS12X compiler supported
%-
%apploc revDate 16.08.2005
%apploc revVer  01.11
%apploc revLvl  9
%apploc revAuth MS
%apploc revVrf  RH
%apploc revCmnt_10 SetSpeedModulesList symbol removed
%apploc revCmnt_10 Description of internal methods added.
%-
%apploc revDate 16.11.2004
%apploc revVer  01.10
%apploc revLvl  9
%apploc revAuth PF
%apploc revVrf  RH
%apploc revCmnt_9 STAMP removed.
%-
%apploc revDate 12.08.2004
%apploc revVer  01.09
%apploc revLvl  5
%apploc revAuth PF
%apploc revVrf  RH
%apploc revCmnt_8 Redundant #includes removed.
%-
%apploc revDate 07.11.2003
%apploc revVer  01.08
%apploc revLvl  2
%apploc revAuth SA
%apploc revVrf  SA
%apploc revCmnt_7 C warnings optimization - typecasting.
%-
%apploc revDate 16.07.2003
%apploc revVer  01.07
%apploc revLvl  5
%apploc revAuth PF
%apploc revVrf  RH
%apploc revCmnt_6 SendChar uninitialized InputBuffer fixed.
%- Na DSP s 16ti bitovou granularitou se pri prijmu znaku v metode SendChar
%- InputBuffer logicky posune pouze o 8 bitu a hornich 8 MSB zustane neinicializovanych
%- RecvChar pak vraci 0xFFxx, coz napriklad implicitne ci explicitne pretypovano na int
%- neni to, co se od toho ceka.
%-
%apploc revDate 22.04.2003
%apploc revVer  01.06
%apploc revLvl  2
%apploc revAuth SA
%apploc revVrf  RH
%apploc revCmnt_5 Support of the Metrowerks HCS08 C compiler and DSP C compiler
%-
%apploc revDate 2.12.2002
%apploc revVer  01.05
%apploc revLvl  4
%apploc revAuth SA
%apploc revVrf  RH
%apploc revCmnt_4 Corrected banking support for PE version for HC08 only.
%-
%apploc revDate 14.10.2002
%apploc revVer  01.04
%apploc revLvl  3
%apploc revAuth SA
%apploc revVrf  RH
%apploc revCmnt_3 MSB first yes/no feature added.
%-
%apploc revDate 08.10.2002
%apploc revVer  01.03
%apploc revLvl  5
%apploc revAuth SA
%apploc revVrf  RH
%apploc revCmnt_2 Banking support
%-
%apploc revDate 30.09.2002
%apploc revVer  01.02
%apploc revLvl  5
%apploc revAuth SA
%apploc revVrf  RH
%apploc revCmnt_1 SetIdleClockPolarity method added
%-
%apploc revDate 21.06.2002
%apploc revVer  01.01
%apploc revLvl  5
%apploc revAuth SA / PF
%apploc revVrf  RH
%apploc revCmnt_0 Support of the Metrowerks HC08/HC12 C compiler
%apploc revCmnt_0 Fixed bug in transmission
%apploc revCmnt_0 ClockEdge property added
%-
%define DriverAuthor  Lubos Lorenc
%- Promazal a upravil Stanislav Adamek
%define DriverVersion 01.15
%define DriverDate    11.10.2001
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%ifdef AfterNewSpeed
  %add AfterNewSpeedList %AfterNewSpeed
%endif
%ifdef BeforeNewSpeed
  %add BeforeNewSpeedList %BeforeNewSpeed
%endif
%-
%-----------------------------------------------------
%-         Definiton section
%-----------------------------------------------------
%-
%define! Delay 1
%-----------------------------------------------------
%-
%INTERFACE
%-define! Settings Common\SWSPISettings.Inc
%define! Abstract Common\GenericSWSPIAbstract.Inc
%include Common\Header.h

#ifndef __%ModuleName
#define __%ModuleName

/* MODULE %ModuleName. */

%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastMode
%ifdef SetFastMode
void %'ModuleName'%.%SetFastMode(void);
%include Common\GenericSWSPISetFastMode.Inc

%endif %- SetFastMode
%-BW_METHOD_END SetFastMode
%-BW_METHOD_BEGIN SetSlowMode
%ifdef SetSlowMode
void %'ModuleName'%.%SetSlowMode(void);
%include Common\GenericSWSPISetSlowMode.Inc

%endif %- SetSlowMode
%-BW_METHOD_END SetSlowMode
%ifdef SharedModules
/*Include shared modules, which are used for whole project*/
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES
%-ENDUSRTYPES
%-BW_METHOD_BEGIN Write_ReadDummy
%ifdef Write_ReadDummy
void %'ModuleName'%.%Write_ReadDummy(uint8_t val);
%define! Parval
%include Common\GenericSWSPIWrite_ReadDummy.Inc

%endif %- Write_ReadDummy
%-BW_METHOD_END Write_ReadDummy
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
uint8_t %'ModuleName'%.%RecvChar(uint8_t *Chr);
%define! ParChr
%define! RetVal
%include Common\GenericSWSPIRecvChar.Inc

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
uint8_t %'ModuleName'%.%SendChar(uint8_t val);
%define! Parval
%define! RetVal
%include Common\GenericSWSPISendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-BW_METHOD_BEGIN CharsInRxBuf
%ifdef CharsInRxBuf
uint8_t %'ModuleName'%.%CharsInRxBuf(void);
%define! RetVal
%include Common\GenericSWSPICharsInRxBuf.Inc

%endif %- CharsInRxBuf
%-BW_METHOD_END CharsInRxBuf
%-BW_METHOD_BEGIN CharsInTxBuf
%ifdef CharsInTxBuf
#define %'ModuleName'%.%CharsInTxBuf()  0 /* we always directly send the characters without buffering */
%define! RetVal
%include Common\GenericSWSPICharsInTxBuf.Inc

%endif %- CharsInTxBuf
%-BW_METHOD_END CharsInTxBuf
%-BW_METHOD_BEGIN SetShiftClockPolarity
%ifdef SetShiftClockPolarity
uint8_t %'ModuleName'%.%SetShiftClockPolarity(uint8_t Edge);
%define! ParEdge
%define! RetVal
%include Common\GenericSWSPISetShiftClockPolarity.Inc

%endif %- SetShiftClockPolarity
%-BW_METHOD_END SetShiftClockPolarity
%-BW_METHOD_BEGIN SetIdleClockPolarity
%ifdef SetIdleClockPolarity
uint8_t %'ModuleName'%.%SetIdleClockPolarity(uint8_t Level);
%define! ParLevel
%define! RetVal
%include Common\GenericSWSPISetIdleClockPolarity.Inc

%endif %- SetIdleClockPolarity
%-BW_METHOD_END SetIdleClockPolarity
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'_Init(void);
%include Common\GeneralInternal.Inc (Init)

%-INTERNAL_METHOD_END Init

/* END %ModuleName. */

#endif /* ifndef __%ModuleName */
%include Common\Header.End
%-
%IMPLEMENTATION
%-define! Settings Common\SWSPISettings.Inc
%define! Abstract Common\GenericSWSPIAbstract.Inc
%include Common\Header.C


/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"

%-
%if (ClockEdge='rising' & SKpolarity='Low') | (ClockEdge='falling' & SKpolarity='High')
  %- clock change, then data, then clock change
  %define ClockDataClock
%else
  %- data, then clock change, then clock change
  /* data-clock-clock */
  %define DataClockClock
%endif
%-
%if defined(SetIdleClockPolarity) | defined(SetShiftClockPolarity)
  %define DynamicClockSettings
%endif

#define OVERRUN_ERR  %#h1                                        %>40/* Overrun error flag bit   */
#define CHAR_IN_RX   %#h8                                        %>40/* Char is in RX buffer     */

%if defined(SetSlowMode) | defined(SetFastMode)
static byte %'ModuleName'%.FastMode; /* 0: slow, 1: fast */
%endif
%if %OutputPinPolarity='Low'
#define MOSI_IDLE_POLARITY    0                                  %>>/* MOSI idle polarity is low */
%else
#define MOSI_IDLE_POLARITY    1                                  %>>/* MOSI idle polarity is high */
%endif
%if %SKpolarity='Low'
#define CLOCK_IDLE_POLARITY   0                                  %>>/* Clock idle polarity is low */
%else
#define CLOCK_IDLE_POLARITY   1                                  %>>/* Clock idle polarity is high */
%endif

%if defined(DynamicClockSettings)
static byte CLKshift;
static byte CLKsampl;
%elif (SKpolarity='Low' & ClockEdge='falling')
/* clock idle low, rising edge: Data - Sample - Shift */
#define CLKsampl  1
#define CLKshift  0
%elif (SKpolarity='Low' & ClockEdge='rising')
/* clock idle low, falling edge: Shift - Data - Sample */
#define CLKshift  1
#define CLKsampl  0
%elif (SKpolarity='High' & ClockEdge='rising')
/* clock idle high, falling edge: Data - Sample - Shift */
#define CLKsampl  0
#define CLKshift  1
%elif (SKpolarity='High' & ClockEdge='falling')
/* clock idle high, rising edge: Shift - Data - Sample */
#define CLKshift  0
#define CLKsampl  1
%endif
static byte InputBuffer;
static byte SerFlag;                                             %>40/* Flags for serial communication */
                                                                 %>40/* Bits: 0 - OverRun error */
                                                                 %>40/*       1 - Unused */
                                                                 %>40/*       2 - Unused */
                                                                 %>40/*       3 - Char in RX buffer */
                                                                 %>40/*       4 - Unused */
                                                                 %>40/*       5 - Unused */
                                                                 %>40/*       6 - Unused */
                                                                 %>40/*       7 - Unused */
#define %'ModuleName'%.DELAY() \
  %if defined(SetSlowMode) | defined(SetFastMode)
    if (%'ModuleName'%.FastMode) { /* we can change the speed at runtime */ \
      %@Wait@'ModuleName'%.Waitus(%FastModeDelayUS);             %>>/* delay for some cycles */ \
    } else { \
      %@Wait@'ModuleName'%.Waitus(%SlowModeDelayUS);             %>>/* delay for some cycles */ \
    }
  %else
    %if %FastModeDelayUS >. '0'
    %@Wait@'ModuleName'%.Waitus(%FastModeDelayUS)                %>>/* delay for some cycles */
    %else
    /* no delay specified by user for fast mode */
    %endif
  %endif
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastMode
%ifdef SetFastMode
%include Common\GenericSWSPISetFastMode.Inc
void %'ModuleName'%.%SetFastMode(void)
{
  %'ModuleName'%.FastMode = 1;
}

%endif %- SetFastMode
%-BW_METHOD_END SetFastMode
%-BW_METHOD_BEGIN SetSlowMode
%ifdef SetSlowMode
%include Common\GenericSWSPISetSlowMode.Inc
void %'ModuleName'%.%SetSlowMode(void)
{
  %'ModuleName'%.FastMode = 0;
}

%endif %- SetSlowMode
%-BW_METHOD_END SetSlowMode
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
%define! ParChr
%define! RetVal
%include Common\GenericSWSPIRecvChar.Inc
uint8_t %'ModuleName'%.%RecvChar(uint8_t *Chr)
{
  if(!(SerFlag & CHAR_IN_RX)) {                                  %>>/* Is char. received */
    return ERR_RXEMPTY;
  }
  *Chr = InputBuffer;                                            %>>/* Store the character */
  if(SerFlag&OVERRUN_ERR) {                                      %>>/* Is "overrun" occurred? */
    SerFlag &= ~(OVERRUN_ERR|CHAR_IN_RX);                        %>>/* If yes, clear flags */
    return ERR_OVERRUN;                                          %>>/* ... and return error */
  } else {
    SerFlag &= ~CHAR_IN_RX;                                      %>>/* If no, clear flag */
    return ERR_OK;                                               %>>/* ... and return */
  }
}

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-BW_METHOD_BEGIN Write_ReadDummy
%ifdef Write_ReadDummy
%define! Parval
%include Common\GenericSWSPIWrite_ReadDummy.Inc
void %'ModuleName'%.%Write_ReadDummy(uint8_t val)
{
  byte i;

  for(i=0; i<8; i++) {
    %'ModuleName'%.DELAY();
%ifdef ClockDataClock
    %@Clk@'ModuleName'%.PutVal(CLKshift);                        %>>/* Set CLK to shift value */
%endif
%if MSB_first = 'yes'
    %@Dout@'ModuleName'%.PutVal((bool)(val&128));                %>>/* Set value on MOSI */
    InputBuffer <<= 1;
%else
    %@Dout@'ModuleName'%.PutVal((bool)(val&1));                  %>>/* Set value on MOSI */
    InputBuffer >>= 1;
%endif
    %'ModuleName'%.DELAY();
    %@Clk@'ModuleName'%.PutVal(CLKsampl);                        %>>/* Set CLK to sample value */
      %if MSB_first = 'yes'
    val <<= 1;
      %else
    val >>= 1;
      %endif
    %ifdef DataClockClock
    %@Clk@'ModuleName'%.PutVal(CLKshift);                        %>>/* Set CLK to shift value */
    %endif
  }
  %@Dout@'ModuleName'%.PutVal((bool)MOSI_IDLE_POLARITY);         %>>/* Set value on MOSI */
}

%endif %- Write_ReadDummy
%-BW_METHOD_END Write_ReadDummy
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! Parval
%define! RetVal
%include Common\GenericSWSPISendChar.Inc
uint8_t %'ModuleName'%.%SendChar(uint8_t val)
{
  byte i;

  for(i=0; i<8; i++) {
    %'ModuleName'%.DELAY();
%ifdef ClockDataClock
    %@Clk@'ModuleName'%.PutVal(CLKshift);                        %>>/* Set CLK to shift value */
%endif
%if MSB_first = 'yes'
    %@Dout@'ModuleName'%.PutVal((bool)(val&128));                %>>/* Set value on MOSI */
    InputBuffer <<= 1;
%else
    %@Dout@'ModuleName'%.PutVal((bool)(val&1));                  %>>/* Set value on MOSI */
    InputBuffer >>= 1;
%endif
    %'ModuleName'%.DELAY();
    %@Clk@'ModuleName'%.PutVal(CLKsampl);                        %>>/* Set CLK to sample value */
      %if MSB_first = 'yes'
      %if %InputPinEnabled='yes'
    InputBuffer |= %@Din@'ModuleName'%.GetVal()?1:0;             %>>/* Read value from MISO */
      %endif
    val <<= 1;
      %else
      %if %InputPinEnabled='yes'
    InputBuffer |= %@Din@'ModuleName'%.GetVal()?128:0;           %>>/* Read value from MISO */
      %endif
    val >>= 1;
      %endif
    %ifdef DataClockClock
    %@Clk@'ModuleName'%.PutVal(CLKshift);                        %>>/* Set CLK to shift value */
    %endif
  }
  %@Dout@'ModuleName'%.PutVal((bool)MOSI_IDLE_POLARITY);         %>>/* Set value on MOSI */
  if(SerFlag&CHAR_IN_RX) {                                       %>>/* Is char. received? */
    SerFlag |= OVERRUN_ERR;                                      %>>/* If yes then set "overrun" flag */
  } else {
    SerFlag |= CHAR_IN_RX;                                       %>>/* If no then set "char in Rx" flag */
  }
  return ERR_OK;
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-BW_METHOD_BEGIN CharsInRxBuf
%ifdef CharsInRxBuf
%define! RetVal
%include Common\GenericSWSPICharsInRxBuf.Inc
uint8_t %'ModuleName'%.%CharsInRxBuf(void)
{
  return (byte)((SerFlag & CHAR_IN_RX)?(byte)1:(byte)0);         %>>/* Return number of chars in receive buffer */
}

%endif %- CharsInRxBuf
%-BW_METHOD_END CharsInRxBuf
%-BW_METHOD_BEGIN CharsInTxBuf
%ifdef CharsInTxBuf
%define! RetVal
%include Common\GenericSWSPICharsInTxBuf.Inc
#if 0 /* implemented as macro in the header file */
uint8_t %'ModuleName'%.%CharsInTxBuf(void)
{
  return 0;                                                      %>>/* Return number of chars in transmit buffer */
}
#endif
%endif %- CharsInTxBuf
%-BW_METHOD_END CharsInTxBuf
%-BW_METHOD_BEGIN SetShiftClockPolarity
%ifdef SetShiftClockPolarity
%define! ParEdge
%define! RetVal
%include Common\GenericSWSPISetShiftClockPolarity.Inc
uint8_t %'ModuleName'%.%SetShiftClockPolarity(uint8_t Edge)
{
  CLKshift = (byte)(Edge?(byte)1:(byte)0);                       %>>/* Set shift value */
  CLKsampl = (byte)(CLKshift ^ (byte)%#h1);                      %>>/* Set sample value */
  return ERR_OK;
}

%endif %- SetShiftClockPolarity
%-BW_METHOD_END SetShiftClockPolarity
%-BW_METHOD_BEGIN SetIdleClockPolarity
%ifdef SetIdleClockPolarity
%define! ParLevel
%define! RetVal
%include Common\GenericSWSPISetIdleClockPolarity.Inc
uint8_t %'ModuleName'%.%SetIdleClockPolarity(uint8_t Level)
{
  %@Clk@'ModuleName'%.PutVal((byte)Level);                       %>>/* Set CLK to (new) idle value */
  return ERR_OK;
}

%endif %- SetIdleClockPolarity
%-BW_METHOD_END SetIdleClockPolarity
%-INTERNAL_METHOD_BEG Init
%include Common\GeneralInternal.Inc (Init)
void %'ModuleName'_Init(void)
{
%ifdef SetSlowMode
  %'ModuleName'%.SetSlowMode();                                  %>>/* slow mode is default */
%endif
%if defined(DynamicClockSettings)
  %if (SKpolarity='Low' & ClockEdge='falling')
  /* clock idle low, falling edge: Data - Sample - Shift */
  CLKsampl = 1;
  CLKshift = 0;
  %elif (SKpolarity='Low' & ClockEdge='rising')
  /* clock idle low, rising edge: Shift - Data - Sample */
  CLKshift = 1;
  CLKsampl = 0;
  %elif (SKpolarity='High' & ClockEdge='rising')
  /* clock idle high, rising edge: Data - Sample - Shift */
  CLKsampl = 0;
  CLKshift = 1;
  %elif (SKpolarity='High' & ClockEdge='falling')
  /* clock idle high, falling edge: Shift - Data - Sample */
  CLKshift = 0;
  CLKsampl = 1;
  %endif
%endif
  %@Clk@'ModuleName'%.PutVal((bool)CLOCK_IDLE_POLARITY);         %>>/* Set CLK to idle value */
  %@Dout@'ModuleName'%.PutVal((bool)MOSI_IDLE_POLARITY);         %>>/* Set value on MOSI */
  SerFlag = 0;                                                   %>>/* Clear flags */
}

%-INTERNAL_METHOD_END Init

/* END %ModuleName. */

%include Common\Header.End
%-
%-

%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'_Init();
%CODE_END
%-
%else %- Language='ANSIC'
  %error^ This bean is not implemented in the selected language & compiler!%--
%endif %- Language='ANSIC'
%-
%DEBUG
%ALL_SYMBOLS
%-
