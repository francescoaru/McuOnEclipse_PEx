%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Erich Styger
%define DriverVersion 01.00
%define DriverDate    25.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FatFsMem_USB_MSDSettings.Inc
%define! Abstract Common\FatFsMem_USB_MSDAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#define %'ModuleName'%.CardPresent() %'ModuleName'%.isDiskPresent()
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg

/* interface for FatFS low level disk functions */
#include "diskio.h"

DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to read (1..255) */
);
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to write (1..255) */
);
#endif
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
);

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
#define %'ModuleName'%.DISK_READ_TIMEOUT_MS   %diskReadTimeoutMs /* disk read timeout in milliseconds */
#define %'ModuleName'%.DISK_WRITE_TIMEOUT_MS  %diskWriteTimeoutMs /* disk write timeout in milliseconds */
#define %'ModuleName'%.DISK_IOCTL_TIMEOUT_MS  %diskIOctlTimeoutMs /* disk ioctl timeout in milliseconds */
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void *data);
%define! Pardata
%define! RetVal
%include Common\FatFsMem_USB_MSDInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
byte %'ModuleName'%.%Deinit(void *data);
%define! Pardata
%define! RetVal
%include Common\FatFsMem_USB_MSDDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
bool %'ModuleName'%.%isDiskPresent(void);
%define! RetVal
%include Common\FatFsMem_USB_MSDisDiskPresent.Inc

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
bool %'ModuleName'%.%isWriteProtected(void);
%define! RetVal
%include Common\FatFsMem_USB_MSDisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN HostInit
%ifdef HostInit
byte %'ModuleName'%.%HostInit(void);
%define! RetVal
%include Common\FatFsMem_USB_MSDHostInit.Inc

%endif %- HostInit
%-BW_METHOD_END HostInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDeviceStatus
%ifdef GetDeviceStatus
dword %'ModuleName'%.%GetDeviceStatus(void);
%define! RetVal
%include Common\FatFsMem_USB_MSDGetDeviceStatus.Inc

%endif %- GetDeviceStatus
%-BW_METHOD_END GetDeviceStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppTask
%ifdef AppTask
void %'ModuleName'%.%AppTask(void);
%include Common\FatFsMem_USB_MSDAppTask.Inc

%endif %- AppTask
%-BW_METHOD_END AppTask
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
#define %'ModuleName'%.%Activate() /* nothing needed */
%include Common\FatFsMem_USB_MSDActivate.Inc

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
#define %'ModuleName'%.%Deactivate() /* nothing needed */
%include Common\FatFsMem_USB_MSDDeactivate.Inc

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FatFsMem_USB_MSDSettings.Inc
%define! Abstract Common\FatFsMem_USB_MSDAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#include "diskio.h"
#include "usb_host_msd_ufi.h"
#include "khci.h"
#include "hidef.h"
#include "poll.h"
#include "msd_commands.h"
#include "usb_host_hub_sm.h"
#include "mem_util.h"

%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/* Command object used in SCSI commands */
static COMMAND_OBJECT_STRUCT pCmd;
static volatile boolean bCallBack = FALSE;
static volatile USB_STATUS bStatus       = USB_OK;

/* the following is the mass storage class driver object structure. This is
used to send commands down to  the class driver. See the Class API document
for details */
volatile DEVICE_STRUCT       mass_device = { 0 };   /* mass storage device struct */

const USB_HOST_DRIVER_INFO DriverInfoTable[] = {
   /* Floppy drive */
   {
      {0x00,0x00},                  /* Vendor ID per USB-IF             */
      {0x00,0x00},                  /* Product ID per manufacturer      */
      USB_CLASS_MASS_STORAGE,       /* Class code                       */
      USB_SUBCLASS_MASS_UFI,        /* Sub-Class code                   */
      USB_PROTOCOL_MASS_BULK,       /* Protocol                         */
      0,                            /* Reserved                         */
      usb_host_mass_device_event    /* Application call back function   */
   },

   /* USB 2.0 hard drive */
   {

      {0x49,0x0D},                  /* Vendor ID per USB-IF             */
      {0x00,0x30},                  /* Product ID per manufacturer      */
      USB_CLASS_MASS_STORAGE,       /* Class code                       */
      USB_SUBCLASS_MASS_SCSI,       /* Sub-Class code                   */
      USB_PROTOCOL_MASS_BULK,       /* Protocol                         */
      0,                            /* Reserved                         */
      usb_host_mass_device_event    /* Application call back function   */
   },

   /* USB 1.1 hub */
   {

      {0x00,0x00},                  /* Vendor ID per USB-IF             */
      {0x00,0x00},                  /* Product ID per manufacturer      */
      USB_CLASS_HUB,                /* Class code                       */
      USB_SUBCLASS_HUB_NONE,        /* Sub-Class code                   */
      USB_PROTOCOL_HUB_LS,          /* Protocol                         */
      0,                            /* Reserved                         */
      usb_host_hub_device_event     /* Application call back function   */
   },

   {
      {0x00,0x00},                  /* All-zero entry terminates        */
      {0x00,0x00},                  /*    driver info list.             */
      0,
      0,
      0,
      0,
      NULL
   }
};

void time_delay(uint_32 delay) {
#if 0 /* too inaccurate? */
  %@Wait@'ModuleName'%.Waitms(delay);
#else
  extern volatile long delay_count; /* needs to be incremented in Events.c by a 1 ms timer */

  delay_count = 0;
  while(delay_count<delay) {
    /* wait */
  }
#endif
}

int_32 _bsp_usb_host_init(pointer param) {
  return 0;
}

void usb_host_mass_device_event
   (
      /* [IN] pointer to device instance */
      _usb_device_instance_handle      dev_handle,

      /* [IN] pointer to interface descriptor */
      _usb_interface_descriptor_handle intf_handle,

      /* [IN] code number for event causing callback */
      uint_32           event_code
   )
{ /* Body */
   switch (event_code) {
      case USB_CONFIG_EVENT:
         /* Drop through into attach, same processing */
      case USB_ATTACH_EVENT:
         if (mass_device.dev_state == USB_DEVICE_IDLE)
         {
            mass_device.dev_handle = dev_handle;
            mass_device.intf_handle = intf_handle;
            mass_device.dev_state = USB_DEVICE_ATTACHED;
         } else {
            //print((unsigned char*)"Mass Storage Device Is Already Attached\n");
         } /* EndIf */
         break;

      case USB_INTF_EVENT:
         mass_device.dev_state = USB_DEVICE_INTERFACED;
         break;

      case USB_DETACH_EVENT:
         if (mass_device.dev_state != USB_DEVICE_IDLE)
         {
            mass_device.dev_handle = NULL;
            mass_device.intf_handle = NULL;
            mass_device.dev_state = USB_DEVICE_DETACHED;
         } else {
           //print((unsigned char*)"Mass Storage Device Is Not Attached\n");
         } /* EndIf */
         break;

      default:
         mass_device.dev_state = USB_DEVICE_IDLE;
         break;
   } /* EndSwitch */
} /* Endbody */

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : callback_bulk_pipe
* Returned Value : None
* Comments       : Called on completion of a control-pipe transaction.
*
*END*--------------------------------------------------------------------*/
void callback_bulk_pipe
    (
        /* [IN] Status of this command */
        USB_STATUS status,
        /* [IN] pointer to USB_MASS_BULK_ONLY_REQUEST_STRUCT*/
        pointer p1,
        /* [IN] pointer to the command object*/
        pointer  p2,
        /* [IN] Length of data transmitted */
        uint_32 buffer_length
   )
{
  (void)p1;
  (void)p2;
  (void)buffer_length;

  bCallBack = TRUE;
  bStatus = status;
} /* Endbody */
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  static uint_8 first_time_flag = TRUE;
  CBW_STRUCT_PTR cbw_ptr;
  CSW_STRUCT_PTR csw_ptr;

  /* Allocate memory for Command Block Wrapper and Command Status Wrapper */
  if (TRUE == first_time_flag) {
    pCmd.CBW_PTR = (CBW_STRUCT_PTR) USB_mem_alloc_word_aligned(sizeof(CBW_STRUCT));
    if (pCmd.CBW_PTR == NULL) {
      return RES_NOT_ENOUGH_CORE;
    }
    pCmd.CSW_PTR = (CSW_STRUCT_PTR) USB_mem_alloc_word_aligned(sizeof(CSW_STRUCT));
    if (pCmd.CSW_PTR == NULL) {
      USB_mem_free(pCmd.CBW_PTR);
      return RES_NOT_ENOUGH_CORE;
    }
    first_time_flag = FALSE;
  } /* EndIf */
  /* Store the address of CBW and CSW */
  cbw_ptr = pCmd.CBW_PTR;
  csw_ptr = pCmd.CSW_PTR;
  memset(pCmd.CSW_PTR, 0, sizeof(CSW_STRUCT));
  memset(pCmd.CBW_PTR, 0, sizeof(CBW_STRUCT));
  memset(&pCmd, 0, sizeof(COMMAND_OBJECT_STRUCT));

  /* Init SCSI command object */
  pCmd.CBW_PTR  = cbw_ptr;
  pCmd.CSW_PTR  = csw_ptr;
  pCmd.LUN      = drv;
  pCmd.CALL_PTR = (pointer)&mass_device.class_intf;
  pCmd.CALLBACK = callback_bulk_pipe;
  return RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to read (1..255) */
)
{
  DRESULT     res = RES_OK;
  USB_STATUS  status = USB_OK;

  (void)drv; /* not used */
  /* Check sector count */
  if (!count) {
    return RES_PARERR;
  }
  /* Send read_10 SCSI command */
  bCallBack = FALSE;
  status = usb_mass_ufi_read_10(&pCmd, sector, buff, (uint_32)(512*count), count);
  if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED)) {
    res = RES_ERROR;
  } else {
#if %'ModuleName'%.DISK_READ_TIMEOUT_MS > 0
    uint16_t timoutMs = %'ModuleName'%.DISK_READ_TIMEOUT_MS;
#endif

    while(!bCallBack) {  /* Wait till command comes back */
      Poll();
#if %'ModuleName'%.DISK_READ_TIMEOUT_MS > 0
      if (timoutMs>0) {
        %@Wait@'ModuleName'%.WaitOSms(1);
        timoutMs--;
      } else {
        bStatus = USBERR_ERROR;
        break; /* leave loop */
      }
#endif
    }
    if (bStatus==USB_OK) {
      res = RES_OK;
    } else {
      res = RES_NOTRDY;
    }
  } /* EndIf */
  return res;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to write (1..255) */
)
{
  DRESULT res = RES_OK;
  USB_STATUS   status = USB_OK;

  (void)drv; /* not used */
  /* Check sector count */
  if (!count) {
    return RES_PARERR;
  }
  /* Send Write_10 SCSI command */
  bCallBack = FALSE;
  status = usb_mass_ufi_write_10(&pCmd, sector, (uchar_ptr)buff, (uint_32)(512*count), count);
  if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED)) {
    res = RES_ERROR;
  } else {
#if %'ModuleName'%.DISK_READ_TIMEOUT_MS > 0
    uint16_t timoutMs = %'ModuleName'%.DISK_WRITE_TIMEOUT_MS;
#endif

    while(!bCallBack) {  /* Wait till command comes back */
      Poll();
#if %'ModuleName'%.DISK_WRITE_TIMEOUT_MS > 0
      if (timoutMs>0) {
        %@Wait@'ModuleName'%.WaitOSms(1);
        timoutMs--;
      } else {
        bStatus = USBERR_ERROR;
        break; /* leave loop */
      }
#endif
    }
    if (!bStatus) {
      res = RES_OK;
    } else {
      res = RES_NOTRDY;
    }
  } /* EndIf */
  return res;
}
#endif /* _READONLY */

/*-----------------------------------------------------------------------*/
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
)
{
#if 1 /* temporary disabled */
  DRESULT      res = RES_OK;
  USB_STATUS   status = USB_OK;
  MASS_STORAGE_READ_CAPACITY_CMD_STRUCT_INFO read_capacity;

  (void)drv; /* not used */
  if ((GET_SECTOR_COUNT == ctrl)||(GET_SECTOR_SIZE == ctrl)) {
    /* Send read_capacity SCSI command */
    bCallBack = FALSE;
    status = usb_mass_ufi_read_capacity(&pCmd, (uchar_ptr)&read_capacity,
         sizeof(MASS_STORAGE_READ_CAPACITY_CMD_STRUCT_INFO));
    if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED)) {
      res = RES_ERROR;
    } else {
#if %'ModuleName'%.DISK_READ_TIMEOUT_MS > 0
    uint16_t timoutMs = %'ModuleName'%.DISK_IOCTL_TIMEOUT_MS;
#endif

      /* Wait till command comes back */
      while(!bCallBack) {
        Poll();
#if %'ModuleName'%.DISK_IOCTL_TIMEOUT_MS > 0
      if (timoutMs>0) {
        %@Wait@'ModuleName'%.WaitOSms(1);
        timoutMs--;
      } else {
        bStatus = USBERR_ERROR;
        break; /* leave loop */
      }
#endif
      }
      if (!bStatus) {
        res = RES_OK;
      } else {
        res = RES_NOTRDY;
      }
    } /* EndIf */
    /* Get number of sectors on the disk (DWORD) */
    if (GET_SECTOR_COUNT == ctrl) {
      *(uint_32 *)buff = *(uint_32 *)read_capacity.BLLBA +1 ;
    } else { /* Get the sector size in byte */
      *(uint_32 *)buff = *(uint_32 *)read_capacity.BLENGTH;
    }
  } else if (GET_BLOCK_SIZE == ctrl) {
    *(uint_32*)buff = 1; /* unknown erase block size */
    res = RES_OK;
  } else if (CTRL_SYNC == ctrl) {
    /* sync/flush any cached blocks */
    res = RES_OK;
  } else{
    res = RES_PARERR;
  } /* EndIf */
  return res;
#else
#define _ALIGNED_
extern uint_8 endpoint_stalled;

  _ALIGNED_ DRESULT                                       res = RES_OK;
    _ALIGNED_ USB_STATUS                                    status = USB_OK;
    _ALIGNED_ MASS_STORAGE_READ_CAPACITY_CMD_STRUCT_INFO    read_capacity;
    static _ALIGNED_ CAPACITY_LIST                          capacity_list;
    static _ALIGNED_ INQUIRY_DATA_FORMAT                    inquiry;
    static _ALIGNED_ REQ_SENSE_DATA_FORMAT                  req_sense;

    UNUSED(drv);

        switch (ctrl)
        {
            case UFI_TEST_UNIT_READY_CMD:
            /* Send test unit ready SCSI command */
            bCallBack = FALSE;
            status = usb_mass_ufi_test_unit_ready(&pCmd);
            if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
            {
                res = RES_ERROR;
            }
            else
            {
                /* Wait till command comes back */
                while(!bCallBack)
                {
                    Poll();
                }

                /*
                * workaround AI:
                * After the endpoint STALL flag is cleared we have to issue another
                * REQUEST_SENSE commmand
                */
        if(endpoint_stalled)
        {
                      endpoint_stalled = FALSE;
                      res = disk_ioctl(0, REQUEST_SENSE_CMD, NULL);
                }

        if (!bStatus)
        {
                      res = RES_OK;
        }
        else
        {
                      res = RES_NOTRDY;
        }
          }
          break;
        case UFI_READ_CAPACITY_CMD:
          /* Send read_capacity SCSI command */
          bCallBack = FALSE;
          status = usb_mass_ufi_read_capacity(&pCmd, (uchar_ptr)&capacity_list,
                   sizeof(CAPACITY_LIST));
          if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
          {
                res = RES_ERROR;
          }
          else
          {
                /* Wait till command comes back */
                while(!bCallBack)
        {
                        Poll();
        }

                if(endpoint_stalled)
        {
            endpoint_stalled = FALSE;
            res = disk_ioctl(0, REQUEST_SENSE_CMD, NULL);
        }

        if (!bStatus)
        {
            res = RES_OK;
        }
        else
        {
            res = RES_NOTRDY;
        }
          }
          break;
        case UFI_READ_FORMAT_CAPACITY_CMD:
          /* Send read_capacity SCSI command */
          bCallBack = FALSE;
          status = usb_mass_ufi_format_capacity(&pCmd, (uchar_ptr)&read_capacity,\
                   sizeof(MASS_STORAGE_READ_CAPACITY_CMD_STRUCT_INFO));
          if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
          {
                res = RES_ERROR;
          }
          else
          {
        /* Wait till command comes back */
        while(!bCallBack)
        {
            Poll();
        }

                if(endpoint_stalled)
        {
            endpoint_stalled = FALSE;
            res = disk_ioctl(0, REQUEST_SENSE_CMD, NULL);
        }

        if (!bStatus)
        {
            res = RES_OK;
        }
        else
        {
            res = RES_NOTRDY;
        }
      }
          break;
        case UFI_INQUIRY_CMD:
          /* Send read_capacity SCSI command */
          bCallBack = FALSE;
          status = usb_mass_ufi_inquiry(&pCmd, (uchar_ptr) &inquiry,
                   sizeof(INQUIRY_DATA_FORMAT));
          if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
          {
        res = RES_ERROR;
          }
          else
          {
        /* Wait till command comes back */
        while(!bCallBack)
        {
            Poll();
        }

        if(endpoint_stalled)
        {
            endpoint_stalled = FALSE;
            res = disk_ioctl(0, REQUEST_SENSE_CMD, NULL);
        }

        if (!bStatus)
        {
            res = RES_OK;
        }
        else
        {
            res = RES_NOTRDY;
        }
          }
          break;
        case REQUEST_SENSE_CMD:
          /* Send read_capacity SCSI command */
          bCallBack = FALSE;
          status = usb_mass_ufi_request_sense(&pCmd, &req_sense,
                   sizeof(REQ_SENSE_DATA_FORMAT));
          if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
          {
                res = RES_ERROR;
          }
          else
          {
        /* Wait till command comes back */
        while(!bCallBack)
        {
                        Poll();
        }

                if (!bStatus)
        {
            res = RES_OK;
        }
        else
        {
                        res = RES_NOTRDY;
        }
          }
          break;
        case GET_SECTOR_COUNT:
        case GET_SECTOR_SIZE:
          /* Send read_capacity SCSI command */
          bCallBack = FALSE;
          status = usb_mass_ufi_read_capacity(&pCmd, (uchar_ptr)&read_capacity,\
                   sizeof(MASS_STORAGE_READ_CAPACITY_CMD_STRUCT_INFO));
          if ((status != USB_OK) && (status != USB_STATUS_TRANSFER_QUEUED))
          {
                res = RES_ERROR;
          }
          else
          {
        /* Wait till command comes back */
        while(!bCallBack)
        {
            Poll();
        }

        if(endpoint_stalled)
        {
            endpoint_stalled = FALSE;
            res = disk_ioctl(0, REQUEST_SENSE_CMD, NULL);
        }

        if (!bStatus)
        {
                        res = RES_OK;
        }
        else
        {
            res = RES_NOTRDY;
        }
          }

          if(!buff)
        return res = RES_ERROR;

          /* Get number of sectors on the disk (DWORD) */
          if (GET_SECTOR_COUNT == ctrl)
          {
        *(uint_32 *)buff = *(uint_32 *)read_capacity.BLLBA +1 ;
          }
          /* Get the sector size in byte */
          else
          {
        *(uint_32 *)buff = *(uint_32 *)read_capacity.BLENGTH;
          }
          break;
        case GET_BLOCK_SIZE:
          if(!buff)
        return res = RES_ERROR;

          *(uint_32*)buff = ERASE_BLOCK_SIZE;
          res = RES_OK;
          break;
        case CTRL_SYNC:
          res = RES_OK;
          break;
        default:
          res = RES_PARERR;
          break;
        }
        return res;
#endif
}

%-BW_CUSTOM_VARIABLE_END

%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! Pardata
%define! RetVal
%include Common\FatFsMem_USB_MSDInit.Inc
byte %'ModuleName'%.%Init(void *data)
{
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! Pardata
%define! RetVal
%include Common\FatFsMem_USB_MSDDeinit.Inc
byte %'ModuleName'%.%Deinit(void *data)
{
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
%define! RetVal
%include Common\FatFsMem_USB_MSDisDiskPresent.Inc
bool %'ModuleName'%.%isDiskPresent(void)
{
  return mass_device.dev_state == USB_DEVICE_INTERFACED;
}

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\FatFsMem_USB_MSDisWriteProtected.Inc
bool %'ModuleName'%.%isWriteProtected(void)
{
  return FALSE; /* no support for write protection */
}

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN HostInit
%ifdef HostInit
%define! RetVal
%include Common\FatFsMem_USB_MSDHostInit.Inc
byte %'ModuleName'%.%HostInit(void)
{
  USB_STATUS           status = USB_OK;
  _usb_host_handle     host_handle;

  /* Initialize the current platform. Call for the _bsp_platform_init which is specific to each processor family */
  /* Init polling global variable */
  POLL_init();

  //DisableInterrupts;
  #if (defined _MCF51MM256_H) || (defined _MCF51JE256_H)
  usb_int_dis();
  #endif
  status = _usb_host_init
    (HOST_CONTROLLER_NUMBER,    /* Use value in header file */
     MAX_FRAME_SIZE,            /* Frame size per USB spec  */
     &host_handle);             /* Returned pointer */

  if (status != USB_OK) {
    //print((unsigned char*)"\nUSB Host Initialization failed. STATUS: 0x%%x"/*, (unsigned int) status*/);
    return ERR_FAILED;
  } /* Endif */

   /*
   ** Since we are going to act as the host driver, register
   ** the driver information for wanted class/subclass/protocols
   */
  status = _usb_host_driver_info_register(host_handle, (void *)DriverInfoTable);
  if (status != USB_OK) {
    //print((unsigned char*)"\nDriver Registration failed. STATUS: 0x%%x"/*, (unsigned int)status*/);
    return ERR_FAILED;
  }

  //EnableInterrupts;
  #if (defined _MCF51MM256_H) || (defined _MCF51JE256_H)
  usb_int_en();
  #endif

  pCmd.CBW_PTR = (CBW_STRUCT_PTR)USB_mem_alloc_word_aligned(sizeof(CBW_STRUCT));
  if (pCmd.CBW_PTR == NULL) {
    //print ((unsigned char*)"\nUnable to allocate Command Block Wrapper!");
    return ERR_FAILED;
  }
  USB_mem_zero(pCmd.CBW_PTR, sizeof(CBW_STRUCT));
  pCmd.CSW_PTR = (CSW_STRUCT_PTR)USB_mem_alloc_word_aligned(sizeof(CSW_STRUCT));
  if (pCmd.CSW_PTR == NULL) {
     //print ((unsigned char*)"\nUnable to allocate Command Status Wrapper!");
     return ERR_FAILED;
  }
  USB_mem_zero(pCmd.CSW_PTR, sizeof(CSW_STRUCT));
  //print((unsigned char*)"\nUSB MSD Application.\nWaiting for USB mass storage to be attached...\n");
  return ERR_OK;
}

%endif %- HostInit
%-BW_METHOD_END HostInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDeviceStatus
%ifdef GetDeviceStatus
%define! RetVal
%include Common\FatFsMem_USB_MSDGetDeviceStatus.Inc
dword %'ModuleName'%.%GetDeviceStatus(void)
{
  return mass_device.dev_state;
}

%endif %- GetDeviceStatus
%-BW_METHOD_END GetDeviceStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppTask
%ifdef AppTask
%include Common\FatFsMem_USB_MSDAppTask.Inc
void %'ModuleName'%.%AppTask(void)
{
  switch (mass_device.dev_state) {
     case USB_DEVICE_IDLE:
       break;
     case USB_DEVICE_ATTACHED:
       mass_device.dev_state = USB_DEVICE_SET_INTERFACE_STARTED;
       /*status = */_usb_hostdev_select_interface(mass_device.dev_handle,
       mass_device.intf_handle, (pointer)&mass_device.class_intf);
       break;
     case USB_DEVICE_SET_INTERFACE_STARTED:
       break;
     case USB_DEVICE_INTERFACED:
       break;
     case USB_DEVICE_DETACHED:
       mass_device.dev_state = USB_DEVICE_IDLE;
       break;
     case USB_DEVICE_OTHER:
       break;
     default:
       break;
  } /* switch */
  Poll();
}

%endif %- AppTask
%-BW_METHOD_END AppTask
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
%include Common\FatFsMem_USB_MSDActivate.Inc
/**
void %'ModuleName'%.%Activate(void)
{
  Implemented as macro on the header file.
}
*/

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
%include Common\FatFsMem_USB_MSDDeactivate.Inc
/**
void %'ModuleName'%.%Deactivate(void)
{
  Implemented as macro on the header file.
}
*/

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START

%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
