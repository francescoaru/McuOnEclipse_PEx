%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Erich Styger
%define DriverVersion 01.00
%define DriverDate    25.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendCommand Sends a command to the SD card
%define! Description_ReceiveByte Receives a byte from the SPI bus
%ifdef LDDHWSPI
  %ifdef @LDDHWSPI@OnBlockReceived
    %define! Description_%@LDDHWSPI@OnBlockReceived This event is called when the requested number of data is moved to the input buffer. This method is available only if the ReceiveBlock method is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDDHWSPI@OnBlockReceived
%endif %- LDDHWSPI
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\SD_CardSettings.Inc
%define! Abstract Common\SD_CardAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
/* interface for FatFS low level disk functions */
#include "diskio.h"

DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to read (1..255) */
);
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to write (1..255) */
);
#endif
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
);
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
/* User definitions */

/* distinguished modes for bus activation/deactivation */
#define %'ModuleName'%.ACTIVATE_MODE_SLOW   0
#define %'ModuleName'%.ACTIVATE_MODE_FAST   1

#define %'ModuleName'%.BLOCK_SIZE   %BlockSize                   %>40 /* user defined block size */

/******************************* SD Card Standard Commands **********************************/
#define %'ModuleName'%.CMD0  (0x40+0)                            %>40 /* Resets the SD Memory Card */
#define %'ModuleName'%.CMD1  (0x40+1)                            %>40 /* Sends host capacity support information and activates the card's
                                                                 %>40    initialization process. HCS is effective when card receives SEND_IF_COND
                                                                 %>40    command. Reserved bits shall be set to '0'. */
#define %'ModuleName'%.CMD6  (0x40+6)                            %>40 /* Checks switchable function (mode 0) and switches card function (mode 1).*/
#define %'ModuleName'%.CMD8  (0x40+8)                            %>40 /* Sends SD Memory Card interface condition that includes host supply voltage
                                                                 %>40    information and asks the accessed card whether card can operate in supplied
                                                                 %>40    voltage range. Reserved bits shall be set to '0'.*/
#define %'ModuleName'%.CMD9  (0x40+9)                            %>40 /* Asks the selected card to send its cardspecific data (CSD)*/
#define %'ModuleName'%.CMD10 (0x40+10)                           %>40 /* Asks the selected card to send its card identification (CID) */
#define %'ModuleName'%.CMD12 (0x40+12)                           %>40 /* Forces the card to stop transmission in Multiple Block Read Operation */
#define %'ModuleName'%.CMD13 (0x40+13)                           %>40 /* Asks the selected card to send its status register. */
#define %'ModuleName'%.CMD16 (0x40+16)                           %>40 /* Sets a block length (in bytes) for all following block commands (read and
                                                                 %>40    write) of a Standard Capacity Card. Block length of the read and write
                                                                 %>40    commands are fixed to 512 bytes in a High Capacity Card. The length of
                                                                 %>40    LOCK_UNLOCK command is set by this command in both capacity cards.*/
#define %'ModuleName'%.CMD17 (0x40+17)                           %>40 /* Reads a block of the size selected by the SET_BLOCKLEN command.*/
#define %'ModuleName'%.CMD18 (0x40+18)                           %>40 /* Continuously transfers data blocks from card to host until interrupted by a
                                                                 %>40    STOP_TRANSMISSION command.*/
#define %'ModuleName'%.CMD24 (0x40+24)                           %>40 /* Writes a block of the size selected by the SET_BLOCKLEN command. */
#define %'ModuleName'%.CMD25 (0x40+25)                           %>40 /* Continuously writes blocks of data until ’Stop Tran’ token is sent
                                                                 %>40   (instead ’Start Block’).*/
#define %'ModuleName'%.CMD27 (0x40+27)                           %>40 /* Programming of the programmable bits of the CSD. */
#define %'ModuleName'%.CMD28 (0x40+28)                           %>40 /* If the card has write protection features, this command sets the write protection bit
                                                                 %>40    of the addressed group. The properties of write protection are coded in the card
                                                                 %>40    specific data (WP_GRP_SIZE). The High Capacity Card does not support this command.*/
#define %'ModuleName'%.CMD29 (0x40+29)                           %>40 /* If the card has write protection features, this command clears the write protection
                                                                 %>40    bit of the addressed group. The High Capacity Card does not support this command. */
#define %'ModuleName'%.CMD30 (0x40+30)                           %>40 /* If the card has write protection features, this command asks the card to send the
                                                                 %>40    status of the write protection bits.6 The High Capacity Card does not support this command. */
#define %'ModuleName'%.CMD32 (0x40+32)                           %>40 /* Sets the address of the first write block to be erased.*/
#define %'ModuleName'%.CMD33 (0x40+33)                           %>40 /* Sets the address of the last write block of the continuous range to be erased. */
#define %'ModuleName'%.CMD38 (0x40+38)                           %>40 /* Erases all previously selected write blocks */
#define %'ModuleName'%.CMD42 (0x40+42)                           %>40 /* Used to Set/Reset the Password or lock/unlock the card. A transferred data block includes
                                                                 %>40    all the command details - refer to Chapter 4.3.7. The size of the Data Block is defined
                                                                 %>40    with SET_BLOCK_LEN command. Reserved bits in the argument and in Lock Card Data Structure
                                                                 %>40    shall be set to 0. */
#define %'ModuleName'%.CMD55 (0x40+55)                           %>40 /* Defines to the card that the next command is an application specific command
                                                                 %>40    rather than a standard command */
#define %'ModuleName'%.CMD56 (0x40+56)                           %>40 /* Used either to transfer a Data Block to the card or to get a Data Block from the card
                                                                 %>40    for general purpose/application specific commands. In case of Standard Capacity SD
                                                                 %>40    Memory Card, the size of the Data Block shall be defined with SET_BLOCK_LEN command.
                                                                 %>40    Block length of this command is fixed to 512-byte in High Capacity Card. */
#define %'ModuleName'%.CMD58 (0x40+58)                           %>40 /* Reads the OCR register of a card. CCS bit is assigned to OCR[30]. */
#define %'ModuleName'%.CMD59 (0x40+59)                           %>40 /* Turns the CRC option on or off. A ‘1’ in the CRC option bit will turn the option on,
                                                                 %>40    a ‘0’ will turn it off */
#define %'ModuleName'%.ACMD41 (0xC0+41)                          %>40 /* SEND_OP_COND (SDC) */
#define %'ModuleName'%.ACMD13 (0xC0+13)                          %>40 /* SD_STATUS (SDC) */
#define %'ModuleName'%.ACMD23 (0xC0+23)                          %>40 /* SET_WR_BLK_ERASE_COUNT (SDC) */

%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void* unused);
%define! Parunused
%define! RetVal
%include Common\SD_CardInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
void %'ModuleName'%.%Activate(void);
%include Common\SD_CardActivate.Inc

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
void %'ModuleName'%.%Deactivate(void);
%include Common\SD_CardDeactivate.Inc

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
#define %'ModuleName'%.%isWriteProtected() \
%if defined(WP) | defined(LDDWP)
  %if WriteProtectIsLow='yes'
  %ifdef LDDWP
  (bool)(%@LDDWP@'ModuleName'%.GetVal(%@LDDWP@'ModuleName'%.DeviceData)==0)%>40 /* low level means write protected */
  %else
  (bool)(%@WP@'ModuleName'%.GetVal()==0)                         %>40 /* low level means write protected */
  %endif
  %else
  %ifdef LDDWP
  (bool)(%@LDDWP@'ModuleName'%.GetVal(%@LDDWP@'ModuleName'%.DeviceData)!=0)%>40 /* high level means write protected */
  %else
  (bool)(%@WP@'ModuleName'%.GetVal()!=0)                         %>40 /* high level means write protected */
  %endif
  %endif
%else
  FALSE                                                          %>40 /* no hardware to detect write protection, thus none */
%endif

%define! RetVal
%include Common\SD_CardisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitReady
%ifdef WaitReady
byte %'ModuleName'%.%WaitReady(void);
%define! RetVal
%include Common\SD_CardWaitReady.Inc

%endif %- WaitReady
%-BW_METHOD_END WaitReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReceiveDataBlock
%ifdef ReceiveDataBlock
bool %'ModuleName'%.%ReceiveDataBlock(byte *data, word nofBytes);
%define! Pardata
%define! ParnofBytes
%define! RetVal
%include Common\SD_CardReceiveDataBlock.Inc

%endif %- ReceiveDataBlock
%-BW_METHOD_END ReceiveDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCmd
%ifdef SendCmd
byte %'ModuleName'%.%SendCmd(byte cmd, dword arg);
%define! Parcmd
%define! Pararg
%define! RetVal
%include Common\SD_CardSendCmd.Inc

%endif %- SendCmd
%-BW_METHOD_END SendCmd
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ReceiveByte
byte %'ModuleName'%.ReceiveByte(void);
%define! RetVal
%include Common\GeneralInternal.inc (ReceiveByte)

%-INTERNAL_METHOD_END ReceiveByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
#define %'ModuleName'%.%CardPresent() \
%if defined(CDI) | defined(LDDCDI)
  %if %CardDetectIsLow='yes'
  %if defined(LDDCDI)
  (bool)(%@LDDCDI@'ModuleName'%.GetVal(%@LDDCDI@'ModuleName'%.DeviceData)==0)%>40 /* low level means card present */
  %else
  (bool)(%@CDI@'ModuleName'%.GetVal()==0)                        %>40 /* low level means card present */
  %endif
  %else
  %if defined(LDDCDI)
  (bool)(%@LDDCDI@'ModuleName'%.GetVal(%@LDDCDI@'ModuleName'%.DeviceData)!=0)%>40 /* high level means card present */
  %else
  (bool)(%@CDI@'ModuleName'%.GetVal()!=0)                        %>40 /* high level means card present */
  %endif
  %endif
%else
  %if %CardPresentIfNoCardDetectionPin='yes'
  TRUE                                                           %>40 /* no card detection pin, but user wants to report TRUE */
  %else
  FALSE                                                          %>40 /* no card detection pin, but user wants to report FALSE */
  %endif
%endif

%define! RetVal
%include Common\SD_CardCardPresent.Inc

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendDataBlock
%ifdef SendDataBlock
bool %'ModuleName'%.%SendDataBlock(byte *data, byte token, word nofBytes);
%define! Pardata
%define! Partoken
%define! ParnofBytes
%define! RetVal
%include Common\SD_CardSendDataBlock.Inc

%endif %- SendDataBlock
%-BW_METHOD_END SendDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastMode
%ifdef SetFastMode
void %'ModuleName'%.%SetFastMode(void);
%include Common\SD_CardSetFastMode.Inc

%endif %- SetFastMode
%-BW_METHOD_END SetFastMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitCommChannel
%ifdef InitCommChannel
void %'ModuleName'%.%InitCommChannel(void);
%include Common\SD_CardInitCommChannel.Inc

%endif %- InitCommChannel
%-BW_METHOD_END InitCommChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
byte %'ModuleName'%.%Deinit(void* unused);
%define! Parunused
%define! RetVal
%include Common\SD_CardDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-INHERITED_EVENT_BEGIN LDDHWSPI OnBlockReceived
%if defined(LDDHWSPI) & defined(@LDDHWSPI@OnBlockReceived)
void %@LDDHWSPI@OnBlockReceived(LDD_TUserData *UserDataPtr);

%endif %- @LDDHWSPI@OnBlockReceived
%-INHERITED_EVENT_END LDDHWSPI OnBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSlowMode
%ifdef SetSlowMode
void %'ModuleName'%.%SetSlowMode(void);
%include Common\SD_CardSetSlowMode.Inc

%endif %- SetSlowMode
%-BW_METHOD_END SetSlowMode
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%INTERFACE OnIdle
void %OnIdle(void);
%include Common\SD_CardOnIdle.Inc

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(void);
%include Common\SD_CardOnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnActivate
%ifdef OnActivate
%INTERFACE OnActivate
void %OnActivate(byte mode);
%define! Parmode
%include Common\SD_CardOnActivate.Inc

%endif %- OnActivate
%-BW_METHOD_END OnActivate
%-BW_METHOD_BEGIN OnDeactivate
%ifdef OnDeactivate
%INTERFACE OnDeactivate
void %OnDeactivate(byte mode);
%define! Parmode
%include Common\SD_CardOnDeactivate.Inc

%endif %- OnDeactivate
%-BW_METHOD_END OnDeactivate
%-BW_METHOD_BEGIN OnBlockReceived
%ifdef OnBlockReceived
%INTERFACE OnBlockReceived
void %OnBlockReceived(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\SD_CardOnBlockReceived.Inc

%endif %- OnBlockReceived
%-BW_METHOD_END OnBlockReceived
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\SD_CardSettings.Inc
%define! Abstract Common\SD_CardAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#include "diskio.h"
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
static volatile DSTATUS Stat = STA_NOINIT;                       %>40 /* Disk status */
static uint8_t CardType = CT_SD1;                                %>40 /* Card type flags */
static uint8_t speedMode = %'ModuleName'%.ACTIVATE_MODE_SLOW;    %>40 /* current speed mode */

enum { /* SD card response codes */
  %'ModuleName'%.OK = 0,
  %'ModuleName'%.IDLE = 1
};

%if defined(SpiBlockTransferEnabled) & %SpiBlockTransferEnabled='yes'
%if defined(HWSPI) %- does not work correctly with HW SPI!
#define %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED          0
#define %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED     0
%else
#define %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED          1
#define %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED     1
%endif
%else
#define %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED          0
#define %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED     0
%endif

/* different wait counters to deal with slow SD cards */
#define %'ModuleName'%.TIMEOUT_READY_MS       %WaitReadyMs       %>40 /* user configured wait timeout until the device is ready */
#define %'ModuleName'%.TIMEOUT_CMD_MS         %WaitCmdMs         %>40 /* user configured wait timeout for commands */
#define %'ModuleName'%.TIMEOUT_READ_BLOCK_MS  %WaitReadBlockMs   %>40 /* user configured wait timeout for reading a data block */
%ifdef SS
#define %'ModuleName'%.ENABLE_SS()   %@SS@'ModuleName'%.ClrVal() /* enable slave (low active) */
#define %'ModuleName'%.DISABLE_SS()  %@SS@'ModuleName'%.SetVal() /* disable slave (low active) */
%elif defined(LDDSS)
#define %'ModuleName'%.ENABLE_SS()   %@LDDSS@'ModuleName'%.ClrVal(%@LDDSS@'ModuleName'%.DeviceData) /* enable slave (low active) */
#define %'ModuleName'%.DISABLE_SS()  %@LDDSS@'ModuleName'%.SetVal(%@LDDSS@'ModuleName'%.DeviceData) /* disable slave (low active) */
%else
#define %'ModuleName'%.ENABLE_SS()   /* dummy macro, as not using slave selection */
#define %'ModuleName'%.DISABLE_SS()  /* dummy macro, as not using slave selection */
%endif
#define %'ModuleName'%.DUMMY 0xff /* SPI dummy value */

/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  uint8_t n, cmd, ty, ocr[4];

  (void)drv; /* not used */
  if (Stat&STA_NODISK) {
    return Stat;                                                 %>40 /* No card in the socket */
  }
  if (%'ModuleName'%.Init(NULL) != ERR_OK) {
    return STA_NOINIT;
  }
  ty = 0;
  if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD0, 0) == 1) {     %>40 /* Enter Idle state */
    if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD8, 0x1AA) == 1) {%>40 /* SDHC */
      for (n = 0; n < 4; n++) {
        ocr[n] = %'ModuleName'%.ReceiveByte();                   %>40 /* Get trailing return value of R7 resp */
      }
      if (ocr[2] == 0x01 && ocr[3] == 0xAA) {                    %>40 /* The card can work at vdd range of 2.7-3.6V */
        while (%'ModuleName'%.SendCmd(%'ModuleName'%.ACMD41, 1UL << 30)) {
          /* Wait for leaving idle state (ACMD41 with HCS bit) */
%if defined(OnIdle)
          %OnIdle();
%endif
        }
        if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD58, 0) == 0) {%>40 /* Check CCS bit in the OCR */
          for (n = 0; n < 4; n++) {
            ocr[n] = %'ModuleName'%.ReceiveByte();
          }
          ty = (uint8_t)((ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2);%>40 /* SDv2 */
        }
      }
    } else {                                                     %>40 /* SDSC or MMC */
      if (%'ModuleName'%.SendCmd(%'ModuleName'%.ACMD41, 0) <= 1) {
        ty = CT_SD1; cmd = %'ModuleName'%.ACMD41;                %>40 /* SDv1 */
      } else {
        ty = CT_MMC; cmd = %'ModuleName'%.CMD1;                  %>40 /* MMCv3 */
      }
      while (%'ModuleName'%.SendCmd(cmd, 0)) {
        /* Wait for leaving idle state */
%if defined(OnIdle)
        %OnIdle();
%endif
      }
      if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD16, %'ModuleName'%.BLOCK_SIZE) != 0) {%>40 /* Set R/W block length  */
        ty = 0;
      }
    }
    %'ModuleName'%.SetFastMode();
  }
  CardType = ty;
  Stat &= ~STA_NOINIT;                                           %>40 /* Clear STA_NOINIT */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= %'ModuleName'%.BLOCK_SIZE;                         %>40 /* Convert to byte address if needed */
  }
  if (count == 1) {                                              %>40 /* Single block read */
    if (   (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD17, sector) == 0)%>40 /* READ_SINGLE_BLOCK */
        && %'ModuleName'%.ReceiveDataBlock(buff, %'ModuleName'%.BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                                                       %>40 /* Multiple block read */
    if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD18, sector) == 0) {%>40 /* READ_MULTIPLE_BLOCK */
      do {
        if (!%'ModuleName'%.ReceiveDataBlock(buff, %'ModuleName'%.BLOCK_SIZE)) {
          break;
        }
        buff += %'ModuleName'%.BLOCK_SIZE;
      } while (--count);
      (void)%'ModuleName'%.SendCmd(%'ModuleName'%.CMD12, 0);     %>40 /* STOP_TRANSMISSION */
    }
  }
  return count ? RES_ERROR : RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= %'ModuleName'%.BLOCK_SIZE;                         %>40 /* Convert to byte address if needed */
  }
  if (count == 1) {                                              %>40 /* Single block write */
    if (  (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD24, sector) == 0)%>40 /* WRITE_BLOCK */
        && %'ModuleName'%.SendDataBlock((byte*)buff, 0xFE, %'ModuleName'%.BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                                                       %>40 /* Multiple block write */
    if (CardType & CT_SDC) {
      (void)%'ModuleName'%.SendCmd(%'ModuleName'%.ACMD23, count);
    }
    if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD25, sector) == 0) {%>40 /* WRITE_MULTIPLE_BLOCK */
      do {
        if (!%'ModuleName'%.SendDataBlock((byte*)buff, 0xFC, %'ModuleName'%.BLOCK_SIZE)) {
          break;
        }
        buff += %'ModuleName'%.BLOCK_SIZE;
      } while (--count);
      if (!%'ModuleName'%.SendDataBlock(0, 0xFD, %'ModuleName'%.BLOCK_SIZE)) {%>40 /* STOP_TRAN token */
        count = 1;
      }
    }
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t n, csd[16], *ptr = (uint8_t*)buff;
  uint16_t csize;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                                                    %>40 /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
        /*lint -save -e522 Highest operation lacks side effect */
          power_off();                                           %>40 /* Power off */
        /*lint -restore */
        }
        break;
      case 1:                                                    %>40 /* Sub control code == 1 (POWER_ON) */
        /*lint -save -e522 Highest operation lacks side effect */
        power_on();                                              %>40 /* Power on */
        /*lint -restore */
        break;
      case 2:                                                    %>40 /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                                           %>40 /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        if (%'ModuleName'%.WaitReady() != ERR_OK) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:                                  %>40 /* get Block Length */
        if ((%'ModuleName'%.SendCmd(%'ModuleName'%.CMD9, 0) == 0) && %'ModuleName'%.ReceiveDataBlock(csd, 16)) {
          switch((csd[5]&15)) {                                  %>40 /* READ_BL_LEN is either 9, 10 or 11, end the block size is 2^READ_BL_LEN */
            case 9: *(uint16_t*)ptr = 512; break;
            case 10: *(uint16_t*)ptr = 1024; break;
            case 11: *(uint16_t*)ptr = 2048; break;
            default: *(uint16_t*)ptr = 0; break; /* illegal */
          }
        }
        break;
      case MMC_GET_SDC_VERSION:                                  %>40 /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        if ((%'ModuleName'%.SendCmd(%'ModuleName'%.CMD9, 0) == 0) && %'ModuleName'%.ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {                              %>40 /* SDC ver 2.00 */
            *ptr = 2;
          } else {                                               %>40 /* SDC ver 1.XX or MMC*/
            *ptr = 1;
          }
        }
        break;
      case GET_SECTOR_COUNT :                                    %>40 /* Get number of sectors on the disk (uint32_t) */
        if ((%'ModuleName'%.SendCmd(%'ModuleName'%.CMD9, 0) == 0) && %'ModuleName'%.ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {                              %>40 /* SDC ver 2.00 */
            csize = (uint16_t)(csd[9] + ((uint16_t)csd[8] << 8) + 1);
            *(uint32_t*)buff = (uint32_t)csize << 10;
          } else {                                               %>40 /* SDC ver 1.XX or MMC*/
            n = (uint8_t)((csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2);
            csize = (uint16_t)((csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1);
            *(uint32_t*)buff = (uint32_t)csize << (byte)(n - 9);
          }
        }
        break;
      case GET_SECTOR_SIZE :                                     %>40 /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = %'ModuleName'%.BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE :                                      %>40 /* Get erase block size in unit of sector (uint32_t) */
        if (CardType & CT_SD2) {                                 %>40 /* SDC ver 2.00 */
          if (%'ModuleName'%.SendCmd(%'ModuleName'%.ACMD13, 0) == 0) {%>40 /* Read SD status */
            (void)%'ModuleName'%.ReceiveByte();
            if (%'ModuleName'%.ReceiveDataBlock(csd, 16)) {      %>40 /* Read partial block */
              for (n = 64 - 16; n; n--) {
                (void)%'ModuleName'%.ReceiveByte();              %>40 /* Purge trailing data */
              }
              *(uint32_t*)buff = 16UL << (csd[10] >> 4);
            }
          }
        } else {                                                 %>40 /* SDC ver 1.XX or MMC */
          if ((%'ModuleName'%.SendCmd(%'ModuleName'%.CMD9, 0) == 0) && %'ModuleName'%.ReceiveDataBlock(csd, 16)) {        /* Read CSD */
            if (CardType & CT_SD1) {                             %>40 /* SDC ver 1.XX */
              *(uint32_t*)buff = (uint32_t)((((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << (byte)((csd[13] >> 6) - 1));
            } else {                                             %>40 /* MMC */
              *(uint32_t*)buff = (uint32_t)(((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1));
            }
          }
        }
        break;
      case MMC_GET_TYPE :                                        %>40 /* Get card type flags (1 byte) */
        *ptr = CardType;
        break;

      case MMC_GET_CSD :                                         %>40 /* Receive CSD as a data block (16 bytes) */
         if (!(%'ModuleName'%.SendCmd(%'ModuleName'%.CMD9, 0) == 0%>40 /* READ_CSD */
            && %'ModuleName'%.ReceiveDataBlock(ptr, 16)))
         {
           res = RES_PARERR;
         }
         break;
      case MMC_GET_CID :                                         %>40 /* Receive CID as a data block (16 bytes) */
        if (!(%'ModuleName'%.SendCmd(%'ModuleName'%.CMD10, 0) == 0%>40 /* READ_CID */
            && %'ModuleName'%.ReceiveDataBlock(ptr, 16)))
        {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_OCR :                                         %>40 /* Receive OCR as an R3 resp (4 bytes) */
        if (%'ModuleName'%.SendCmd(%'ModuleName'%.CMD58, 0) == 0) {%>40 /* READ_OCR */
          for (n = 4; n; n--) {
            *ptr++ = %'ModuleName'%.ReceiveByte();
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_SDSTAT :                                      %>40 /* Receive SD status as a data block (64 bytes) */
        if (%'ModuleName'%.SendCmd(%'ModuleName'%.ACMD13, 0) == 0) {%>40 /* SD_STATUS */
          (void)%'ModuleName'%.ReceiveByte();
          if (!%'ModuleName'%.ReceiveDataBlock(ptr, 64)) {
            res = RES_PARERR;
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_DRIVER_VERSION:                               %>40 /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 0;
        break;

      default:
        res = RES_PARERR;
    } /* switch */
  } /* if-else */
  return res;
}

%if SPI_Read_Write_Macros='yes'
/* SPI Read/Write macros provided by user */
%for i from SPIMacrosList
                                                                 %>5 %i
%endfor
#define %'ModuleName'%.SPI_WRITE(write)                          %>40 SPI_WRITE(write)
#define %'ModuleName'%.SPI_WRITE_READ(write, readP)              %>40 SPI_WRITE_READ(write, readP)

%endif
%ifdef HWSPI
#if %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED
static void %'ModuleName'%.SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  unsigned char dummy[4];
  uint16_t writeSize;
  uint16_t snt;

  while(size>0) {
    if (size>sizeof(dummy)) {
      writeSize = sizeof(dummy);
    } else {
      writeSize = size;
    }
    (void)%@HWSPI@'ModuleName'%.SendBlock(writeP, writeSize, &snt);
    (void)%@HWSPI@'ModuleName'%.RecvBlock(&dummy[0], writeSize, &snt);
    size -= writeSize;
    writeP += writeSize;
  }
}
#endif /* %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED */

#if %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED
static void %'ModuleName'%.SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  uint16_t dummy;

  (void)%@HWSPI@'ModuleName'%.SendBlock(writeP, size, &dummy);
  (void)%@HWSPI@'ModuleName'%.RecvBlock(readP, size, &dummy);
}
#endif /* %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED */

%if SPI_Read_Write_Macros='no'
static byte rxDummy; /* dummy byte if we do not need the result. Needed to read from SPI register. */
#define %'ModuleName'%.SPI_WRITE(write)            \
   { \
     while(%@HWSPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@HWSPI@'ModuleName'%.RecvChar(&rxDummy)!=ERR_OK) {} \
   }
#define %'ModuleName'%.SPI_WRITE_READ(write, readP) \
   { \
     while(%@HWSPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@HWSPI@'ModuleName'%.RecvChar(readP)!=ERR_OK) {} \
   }
#if 0 /* reference example implementation for MCF51CN128 */
#if 0 /* example for TWR-MCF51CN128 */
#define SPI_WRITE(write) \
   { \
     while(SPI2S_SPTEF==0) {} /* wait until transmitter is not full */ \
     SPI2D = write; /* send character */ \
     while(SPI2S_SPTEF==0) {} /* wait until character is sent */ \
   }

#define SPI_WRITE_READ(write, readP) \
   { \
     SPI_WRITE(write); \
     while(SPI2S_SPRF==0) {} /* wait until rx is complete */ \
     *readP = SPI2D; /* store rx character */ \
   }
#endif
#if 0 /* example for TWR-MCF52259 */
#define SPI_WRITE(write) \
  { \
  while((QDLYR&QDLYR_SPE_BITMASK)!=0) {} /* wait until previous transmit is over (SPE goes to zero) */ \
  QAR = 0;                     /* Set transmit RAM */ \
  QDR = write;                   /* Store char to transmitter */ \
  QDLYR |= QDLYR_SPE_BITMASK;            /* Launch transfer (set SPE bit) */ \
  while((QDLYR&QDLYR_SPE_BITMASK)!=0) {} /* wait until character is sent (SPE will be cleared by hardware) */ \
  }

#define SPI_WRITE_READ(write, readP) \
  { \
  SPI_WRITE(write); \
  while(!(QIR&QIR_SPIF_BITMASK)) {} /* wait until rx is complete */ \
  QAR = 16;                    /* Set receive RAM */ \
  *readP = (SM1_TComData)getReg16(QDR);  /* Read data from receiver */ \
  }
#endif

#endif
%endif
#define %'ModuleName'%.SPI_Enable()                   (void)%@HWSPI@'ModuleName'%.Enable()
#define %'ModuleName'%.SPI_Disable()                  (void)%@HWSPI@'ModuleName'%.Disable()
#define %'ModuleName'%.SPI_SetSlowMode()              (void)%@HWSPI@'ModuleName'%.SetBaudRateMode(%HWSlowBaudRateMode) /* max 400kbps */
#define %'ModuleName'%.SPI_SetFastMode()              (void)%@HWSPI@'ModuleName'%.SetBaudRateMode(%HWFastBaudRateMode) /* max 12Mbps */
#define %'ModuleName'%.SPI_SetShiftClockPolarity(val) (void)%@HWSPI@'ModuleName'%.SetShiftClockPolarity(val)
#define %'ModuleName'%.SPI_SetIdleClockPolarity(val)  (void)%@HWSPI@'ModuleName'%.SetIdleClockPolarity(val)
%endif %- HWSPI
%---------------------------------------------------------------------------------------------------
%ifdef LDDHWSPI
#define %'ModuleName'%.SPI_Enable()                   (void)%@LDDHWSPI@'ModuleName'%.Enable(%@LDDHWSPI@'ModuleName'%.DeviceData)
#define %'ModuleName'%.SPI_Disable()                  (void)%@LDDHWSPI@'ModuleName'%.Disable(%@LDDHWSPI@'ModuleName'%.DeviceData)
#define %'ModuleName'%.SPI_SetSlowMode()              (void)%@LDDHWSPI@'ModuleName'%.SelectConfiguration(%@LDDHWSPI@'ModuleName'%.DeviceData, %HWSlowBaudRateMode, %HWSlowBaudRateMode) /* max 400kbps */
#define %'ModuleName'%.SPI_SetFastMode()              (void)%@LDDHWSPI@'ModuleName'%.SelectConfiguration(%@LDDHWSPI@'ModuleName'%.DeviceData, %HWFastBaudRateMode, %HWFastBaudRateMode) /* max 12Mbps */
#define %'ModuleName'%.SPI_SetShiftClockPolarity(val) /* not needed for LDD */
#define %'ModuleName'%.SPI_SetIdleClockPolarity(val)  /* not needed for LDD */

static volatile bool %'ModuleName'%.DataReceivedFlag = FALSE;

void %'ModuleName'%.SPI_WRITE(unsigned char write) {
  unsigned char dummy;

  %'ModuleName'%.DataReceivedFlag = FALSE;
  (void)%@LDDHWSPI@'ModuleName'%.ReceiveBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, &dummy, sizeof(dummy));
  (void)%@LDDHWSPI@'ModuleName'%.SendBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, &write, sizeof(write));
  while(!%'ModuleName'%.DataReceivedFlag){}
}

#if %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED
static void %'ModuleName'%.SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  unsigned char dummy[4];
  uint16_t writeSize;

  while(size>0) {
    if (size>sizeof(dummy)) {
      writeSize = sizeof(dummy);
    } else {
      writeSize = size;
    }
    %'ModuleName'%.DataReceivedFlag = FALSE;
    (void)%@LDDHWSPI@'ModuleName'%.ReceiveBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, &dummy[0], writeSize);
    (void)%@LDDHWSPI@'ModuleName'%.SendBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, writeP, writeSize);
    while(!%'ModuleName'%.DataReceivedFlag){}
    size -= writeSize;
    writeP += writeSize;
  }
}
#endif /* %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED */

static void %'ModuleName'%.SPI_WRITE_READ(unsigned char write, unsigned char *readP) {
  %'ModuleName'%.DataReceivedFlag = FALSE;
  (void)%@LDDHWSPI@'ModuleName'%.ReceiveBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, readP, 1);
  (void)%@LDDHWSPI@'ModuleName'%.SendBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, &write, 1);
  while(!%'ModuleName'%.DataReceivedFlag){}
}

#if %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED
static void %'ModuleName'%.SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  %'ModuleName'%.DataReceivedFlag = FALSE;
  (void)%@LDDHWSPI@'ModuleName'%.ReceiveBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, readP, size);
  (void)%@LDDHWSPI@'ModuleName'%.SendBlock(%@LDDHWSPI@'ModuleName'%.DeviceData, writeP, size);
  while(!%'ModuleName'%.DataReceivedFlag){}
}
#endif /* %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED */

%endif %- LDDHWSPI

#if %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED || %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED
#define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 512 /* 512 bytes of dummy values */
static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY,
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY,
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY,
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY,
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY,
  %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY, %'ModuleName'%.DUMMY
};
#endif
%---------------------------------------------------------------------------------------------------
%ifdef SPI /* SW SPI */
%if SPI_Read_Write_Macros='no'
#define %'ModuleName'%.SPI_WRITE(write)               ((void)%@SPI@'ModuleName'%.Write_ReadDummy(write))
#define %'ModuleName'%.SPI_WRITE_READ(write, readP)   {(void)%@SPI@'ModuleName'%.SendChar(write); (void)%@SPI@'ModuleName'%.RecvChar(readP);}
%endif
#define %'ModuleName'%.SPI_SetFastMode()              %@SPI@'ModuleName'%.SetFastMode()
#define %'ModuleName'%.SPI_SetSlowMode()              %@SPI@'ModuleName'%.SetSlowMode()
#define %'ModuleName'%.SPI_SetShiftClockPolarity(val) (void)%@SPI@'ModuleName'%.SetShiftClockPolarity(val)
#define %'ModuleName'%.SPI_SetIdleClockPolarity(val)  (void)%@SPI@'ModuleName'%.SetIdleClockPolarity(val)

#if %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED
static void %'ModuleName'%.SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  while(size>0) {
    %@SPI@'ModuleName'%.Write_ReadDummy(*writeP);
    writeP++;
    size--;
  }
}

static void %'ModuleName'%.SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  uint8_t res;

  while(size>0) {
    res = %@SPI@'ModuleName'%.SendChar(*writeP);
    if (res!=ERR_OK) {
      break;
    }
    writeP++;
    res = %@SPI@'ModuleName'%.RecvChar(readP);
    if (res!=ERR_OK) {
      break;
    }
    readP++;
    size--;
  }
}
#endif /* %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED */
%endif
%-BW_CUSTOM_VARIABLE_END

%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SendCommand
static byte SendCommand(byte cmd, byte *arg, byte response);
%-INTERNAL_LOC_METHOD_END SendCommand
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
%include Common\SD_CardActivate.Inc
void %'ModuleName'%.%Activate(void)
{
  /* Note that the SD card SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
   * typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
%if defined(OnActivate)
  %OnActivate(speedMode);
%endif
  %'ModuleName'%.%InitCommChannel();
%if defined(ACT)
  %@ACT@'ModuleName'%.SetVal();                                  %>40 /* enable bus driver (high level) */
%elif defined(LDDACT)
  %@LDDACT@'ModuleName'%.SetVal(%@LDDACT@'ModuleName'%.DeviceData);%>40 /* enable bus driver (high level) */
%endif
  %'ModuleName'%.ENABLE_SS();                                    %>40 /* select slave */
}

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
%include Common\SD_CardDeactivate.Inc
void %'ModuleName'%.%Deactivate(void)
{
  %'ModuleName'%.DISABLE_SS();                                   %>40 /* de-select slave */
%if defined(ACT)
  %@ACT@'ModuleName'%.ClrVal();                                  %>40 /* disable bus driver (low level) */
%elif defined(LDDACT)
  %@LDDACT@'ModuleName'%.ClrVal(%@LDDACT@'ModuleName'%.DeviceData);%>40 /* disable bus driver (low level) */
%endif
%if defined(OnDeactivate)
  %OnDeactivate(speedMode);
%endif
}

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitReady
%ifdef WaitReady
%define! RetVal
%include Common\SD_CardWaitReady.Inc
byte %'ModuleName'%.%WaitReady(void)
{
  byte tmp;
  %@Timeout@'ModuleName'%.CounterHandle timeout;

  %'ModuleName'%.Activate();
  %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);
  timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_READY_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS);%>40/* set up timeout counter */
  for (;;) {                                                     %>40 /* will timeout */
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &tmp);   %>40 /* write dummy value, read status */
    if (tmp==0xff) {
      break;
    }
    if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
      break;
    }
%if defined(OnIdle)
    %OnIdle();
%endif
  } /* for */
  %@Timeout@'ModuleName'%.LeaveCounter(timeout);
  %'ModuleName'%.Deactivate();
  if (tmp==0xff) {
    return ERR_OK; /* device is ready */
  } else {
%ifdef OnError
    %OnError();
%endif
    return ERR_BUSY;
  }
}

%endif %- WaitReady
%-BW_METHOD_END WaitReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReceiveDataBlock
%ifdef ReceiveDataBlock
%define! Pardata
%define! ParnofBytes
%define! RetVal
%include Common\SD_CardReceiveDataBlock.Inc
bool %'ModuleName'%.%ReceiveDataBlock(byte *data, word nofBytes)
{
  byte tmp;
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  word cnt = 512; /* polling counter */

  %'ModuleName'%.Activate();
  /* poll response */
  do {
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &tmp);   %>40 /* send dummy value, poll response */
    cnt--;
  } while (tmp==0xFF && cnt>0);
  if (tmp==0xFF) { /* polling not successful, now poll for a longer period of time */
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_READ_BLOCK_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS);%>40/* timeout */
    for (;;) {                                                   %>40 /* will timeout */
      %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &tmp); %>40 /* send dummy value, poll response */
      if (tmp!=0xFF) {
        break;
      }
  %if defined(RTOS)
      if (%@Timeout@'ModuleName'%.Value(timeout)!=(%'ModuleName'%.TIMEOUT_READ_BLOCK_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS)) {
        /* polled already for a tick period: use RTOS wait in order to balance CPU cycles */
        %@RTOS@'ModuleName'%.vTaskDelay(portTICK_RATE_MS);
      }
  %endif
      if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
        break;
      }
  %if defined(OnIdle)
      %OnIdle();
  %endif
    } /* for */
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
  } /* if */
  if (tmp != 0xFE) {                                             %>40 /* if it is not expected response, return with error */
%ifdef OnError
    %OnError();
%endif
    %'ModuleName'%.Deactivate();
    return FALSE;
  }
  /*lint -save -e539 Did not expect positive indentation  */
#if %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED
  if (nofBytes<=SPI_WRITE_READ_BLOCK_SIZE_DUMMY) {
    %'ModuleName'%.SPI_WRITE_READ_BLOCK((unsigned char*)&dummyArr[0], data, nofBytes);%>40 /* write dummy value, read data */
  } else {
#endif
    while(nofBytes>0) {
      %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, data); %>40 /* write dummy value, read data */
      data++;
      nofBytes--;
    }
#if %'ModuleName'%.SPI_WRITE_READ_BLOCK_ENABLED
  }
#endif
  /*lint -restore Did not expect positive indentation */
  %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);                %>40 /* checksum Bytes not needed */
  %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);
  %'ModuleName'%.Deactivate();
  return TRUE;
}

%endif %- ReceiveDataBlock
%-BW_METHOD_END ReceiveDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendDataBlock
%ifdef SendDataBlock
%define! Pardata
%define! Partoken
%define! ParnofBytes
%define! RetVal
%include Common\SD_CardSendDataBlock.Inc
bool %'ModuleName'%.%SendDataBlock(byte *data, byte token, word nofBytes)
{
  byte resp;

  if (%'ModuleName'%.WaitReady()!=ERR_OK) {
%ifdef OnError
    %OnError();
%endif
    return FALSE;                                                %>40 /* device not ready */
  }
  %'ModuleName'%.Activate();
  %'ModuleName'%.SPI_WRITE(token);                               %>40 /* Xmit data token */
  if (token != 0xFD) {                                           %>40 /* Is data token, not STOP_TRAN */
#if %'ModuleName'%.SPI_WRITE_BLOCK_ENABLED
    %'ModuleName'%.SPI_WRITE_BLOCK(data, nofBytes);
#else
    while (nofBytes!=0) {                                        %>40 /* send the bytes */
      %'ModuleName'%.SPI_WRITE(*data);
      data++;
      nofBytes--;
    }
#endif
    %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);              %>40 /* CRC (Dummy) */
    %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);              %>40 /* CRC (Dummy) */
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &resp);  %>40 /* write dummy value, receive data response */
    if ((resp&0x1F) != 0x05) {                                   %>40 /* If not accepted, return with error */
%ifdef OnError
      %OnError();
%endif
      %'ModuleName'%.Deactivate();
      return FALSE;
    }
    /* if we do not poll the device for its busy state, we need to provide at least 8 clocks (dummy cycle).
     * See http://elm-chan.org/docs/mmc/mmc_e.html:
     *    In principle of the SPI mode, the CS signal must be asserted during a transaction,
     *    however there is an exception to this rule. When the card is busy, the host controller
     *    can deassert CS to release SPI bus for any other SPI devices. The card will drive DO signal
     *    low again when reselect it during internal process is in progress.
     *    Therefore a preceding busy check (wait ready immediately before command and data packet)
     *    instead of post wait can eliminate waste wait time. In addition the internal process is initiated
     *    a byte after the data response, this means eight clocks are required to initiate internal write operation.
     */
    %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);
  }
  %'ModuleName'%.Deactivate();
  return TRUE;
}

%endif %- SendDataBlock
%-BW_METHOD_END SendDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCmd
%ifdef SendCmd
%define! Parcmd
%define! Pararg
%define! RetVal
%include Common\SD_CardSendCmd.Inc
%if defined(COMPILER_HIX)
#pragma MESSAGE DISABLE C1855 /* recursive function call */
%endif
byte %'ModuleName'%.%SendCmd(byte cmd, dword arg)
{
  byte n, res;
  %@Timeout@'ModuleName'%.CounterHandle timeout;

  if (cmd&0x80) {                                                %>40 /* ACMD<n> is the command sequence of CMD55-CMD<n> */
    cmd &= 0x7F;
    res = %'ModuleName'%.SendCmd(%'ModuleName'%.CMD55, 0);
    if (res > 1) {
      return res;
    }
  }
  /* Select the card and wait for ready */
  if (%'ModuleName'%.WaitReady() != ERR_OK) {
%ifdef OnError
    %OnError();
%endif
    return 0xFF;
  }
  %'ModuleName'%.Activate();
  /* Send command packet */
  %'ModuleName'%.SPI_WRITE(cmd);                                 %>40 /* Start + Command index */
  n = (byte)(arg>>24);
  %'ModuleName'%.SPI_WRITE(n);                                   %>40 /* Argument[31..24] */
  n = (byte)(arg>>16);
  %'ModuleName'%.SPI_WRITE(n);                                   %>40 /* Argument[23..16] */
  n = (byte)(arg>>8);
  %'ModuleName'%.SPI_WRITE(n);                                   %>40 /* Argument[15..8] */
  %'ModuleName'%.SPI_WRITE((byte)arg);                           %>40 /* Argument[7..0] */
  if (cmd == %'ModuleName'%.CMD0) {
    n = 0x95;                                                    %>40 /* Valid CRC for CMD0(0) */
  } else if (cmd == %'ModuleName'%.CMD8) {
    n = 0x87;                                                    %>40 /* Valid CRC for CMD8(0x1AA) */
  } else {
    n = 0x01;                                                    %>40 /* Dummy CRC + Stop */
  }
  %'ModuleName'%.SPI_WRITE(n);
  /* Receive command response */
  if (cmd == %'ModuleName'%.CMD12) {
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &res);   %>40 /* send dummy value, poll response */
  }
  timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_CMD_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS);%>40/* timeout */
  for(;;) {                                                      %>40/* will timeout */
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &res);   %>40/* send dummy value, poll response */
    if (!(res&0x80)) {                                           %>40/* valid response */
      break;
    }
    if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
      break;
    }
%if defined(OnIdle)
    %OnIdle();
%endif
  }
  %@Timeout@'ModuleName'%.LeaveCounter(timeout);
  %'ModuleName'%.Deactivate();
  return res;                                                    %>40 /* Return with the response value */
}
%if defined(COMPILER_HIX)
#pragma MESSAGE DEFAULT C1855 /* recursive function call */
%endif
%endif %- SendCmd
%-BW_METHOD_END SendCmd
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\SD_CardisWriteProtected.Inc
/*
bool %'ModuleName'%.%isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendCommand
%define! Parcmd
%define! Parresponse
%define! Pararg
%define! RetVal
%include Common\GeneralInternalGlobal.inc (SendCommand)
static byte SendCommand(byte cmd, byte *arg, byte response)
{
  #define NOF_WAIT_ITERATIONS 3
  byte u8Temp=0;
  byte u8Counter;

  %'ModuleName'%.Activate();
  %'ModuleName'%.SPI_WRITE(cmd);                                 %>40 /* Send Start byte */
  /* Send Argument */
  for(u8Counter=0; u8Counter<4; u8Counter++) {
    %'ModuleName'%.SPI_WRITE(arg[u8Counter]);
  }
  %'ModuleName'%.SPI_WRITE(0x95);                                %>40 /* Send CRC */
  /* Response Handler */
  for (u8Counter=0;u8Counter<NOF_WAIT_ITERATIONS;u8Counter++) {
    %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &u8Temp);%>40 /* send dummy value, poll response */
    if (u8Temp==response) {
      break;
    }
%if defined(OnIdle)
    %OnIdle();
%endif
  } /* for */
  %'ModuleName'%.Deactivate();
  if (u8Temp==response) {
    return ERR_OK;
  } else {
%ifdef OnError
    %OnError();
%endif
    return ERR_FAULT;
  }
}

%-INTERNAL_METHOD_END SendCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! Parunused
%define! RetVal
%include Common\SD_CardInit.Inc
byte %'ModuleName'%.%Init(void* unused)
{
  /* The behavior of SD cards in SPI mode is basically the same as for any SPI slave device.
     The maximum transfer rate of the SD card in SPI mode is 25 Mbps, but in the initialization process the
     transfer rate must be less than 375 kbps. This is because the SPI mode of the SD cards is compatible with
     the MMC cards, and MMC cards can only reach 375 kbps. After initialization, the SPI clock can be
     changed to 25 Mbps.
     Note that the SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
     typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  dword arg;
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout = FALSE;
  byte cnt;

  (void)unused;
  /* -------------------------------- Init & Slow Mode -------------------------------- */
  /* after voltage reaches 2.2V, need to wait at least 1 ms. Then we need to set Data and CS/Chipselect high for at least 74 clocks */
  /*lint -save -e522 function lacks side-effects */
  %@Wait@'ModuleName'%.Waitms(1);                                %>40 /* wait at least for 1 ms on insertion and power on */
  /*lint -restore */
  speedMode = %'ModuleName'%.ACTIVATE_MODE_SLOW;
  %'ModuleName'%.Activate();                                     %>40 /* select slave */
  %'ModuleName'%.SetSlowMode();                                  %>40 /* set the SPI clock to 375 kbps. This is required for compatibility across a wide range of SD and MMC cards. */
  %'ModuleName'%.DISABLE_SS();                                   %>40 /* disable slave (CS high) */
  for(cnt=0;cnt<10;cnt++) {                                      %>40 /* send at least 75 SPI clock cycles with the SS signal asserted to ensure that the SD card internal state machine is initialized. */
    %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);
  }
  /*lint -save -e522 function lacks side-effects */
  %@Wait@'ModuleName'%.Waitus(50);                               %>40 /* need to wait a little bin in order SPI transfer to be finished (need this on CN128, but on others too?) */
  /*lint -restore */
  %'ModuleName'%.Deactivate();
  /* -------------------------------- IDLE Command -------------------------------- */
  arg = 0;
  timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_READY_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS);%>40/* timeout */
  while (SendCommand(%'ModuleName'%.CMD0, (byte*)&arg, %'ModuleName'%.IDLE) != ERR_OK) {
    if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
      isTimeout = TRUE;                                          %>40/* indicate a timeout */
      break;
    }
%if defined(OnIdle)
    %OnIdle();
%endif
  } /* while */
  %@Timeout@'ModuleName'%.LeaveCounter(timeout);
  if (isTimeout) {                                               %>40 /* timeout */
%ifdef OnError
    %OnError();
%endif
    return ERR_FAULT;
  }
  /* Send 8 SPI clocks (SS unasserted). */
  %'ModuleName'%.Activate();
  %'ModuleName'%.DISABLE_SS();                                   %>40 /* disable slave */
  %'ModuleName'%.SPI_WRITE(%'ModuleName'%.DUMMY);                %>40 /* dummy SPI cycle */
  %'ModuleName'%.Deactivate();                                   %>40 /* de-select slave */
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ReceiveByte
%define! RetVal
%include Common\GeneralInternal.inc (ReceiveByte)
byte %'ModuleName'%.ReceiveByte(void)
{
  byte data;

  %'ModuleName'%.Activate();
  %'ModuleName'%.SPI_WRITE_READ(%'ModuleName'%.DUMMY, &data);    %>40 /* send dummy value, poll response */
  %'ModuleName'%.Deactivate();
  return data;
}

%-INTERNAL_METHOD_END ReceiveByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
%define! RetVal
%include Common\SD_CardCardPresent.Inc
/*
bool %'ModuleName'%.%CardPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSlowMode
%ifdef SetSlowMode
%include Common\SD_CardSetSlowMode.Inc
void %'ModuleName'%.%SetSlowMode(void)
{
%ifdef LDDHWSPI
#if 0 /* if using LDD component, do not disable the SPI, as %'ModuleName'%.SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
%endif
  %'ModuleName'%.SPI_Disable();
%ifdef LDDHWSPI
#endif
%endif
%if defined(HWSPI)
  (void)%@HWSPI@'ModuleName'%.SetIdleClockPolarity(0);           %>40 /* low idle clock polarity */
  (void)%@HWSPI@'ModuleName'%.SetShiftClockPolarity(0);          %>40 /* shift clock polarity: falling edge */
%endif
  %'ModuleName'%.SPI_SetSlowMode();                              %>40 /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
  speedMode = %'ModuleName'%.ACTIVATE_MODE_SLOW;
%ifdef LDDHWSPI
#if 0 /* if using LDD component, do not disable the SPI, as %'ModuleName'%.SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
%endif
  %'ModuleName'%.SPI_Enable();
%ifdef LDDHWSPI
#endif
%endif
}

%endif %- SetSlowMode
%-BW_METHOD_END SetSlowMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastMode
%ifdef SetFastMode
%include Common\SD_CardSetFastMode.Inc
void %'ModuleName'%.%SetFastMode(void)
{
%ifdef LDDHWSPI
#if 0 /* if using LDD component, do not disable the SPI, as %'ModuleName'%.SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
%endif
  %'ModuleName'%.SPI_Disable();
%ifdef LDDHWSPI
#endif
%endif
%if defined(HWSPI)
  (void)%@HWSPI@'ModuleName'%.SetIdleClockPolarity(0);           %>40 /* low idle clock polarity */
  (void)%@HWSPI@'ModuleName'%.SetShiftClockPolarity(0);          %>40 /* shift clock polarity: falling edge */
%endif
  %'ModuleName'%.SPI_SetFastMode();                              %>40 /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
  speedMode = %'ModuleName'%.ACTIVATE_MODE_FAST;
%ifdef LDDHWSPI
#if 0 /* if using LDD component, do not disable the SPI, as %'ModuleName'%.SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
%endif
  %'ModuleName'%.SPI_Enable();
%ifdef LDDHWSPI
#endif
%endif
}

%endif %- SetFastMode
%-BW_METHOD_END SetFastMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitCommChannel
%ifdef InitCommChannel
%include Common\SD_CardInitCommChannel.Inc
void %'ModuleName'%.%InitCommChannel(void)
{
  /* Settings:
    - 100-400 kHz clock during init, then max 12 MHz
    - Send MSB first
    - Shift clock idle polarity: low
    - Clock edge: falling edge
  */
  if (speedMode==%'ModuleName'%.ACTIVATE_MODE_FAST) {
    %'ModuleName'%.SetFastMode(); /* use fast mode. */
  } else {
    %'ModuleName'%.SetSlowMode(); /* use slow mode. */
  }
}

%endif %- InitCommChannel
%-BW_METHOD_END InitCommChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! Parunused
%define! RetVal
%include Common\SD_CardDeinit.Inc
byte %'ModuleName'%.%Deinit(void* unused)
{
  (void)unused;
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-INHERITED_EVENT_BEGIN LDDHWSPI OnBlockReceived
%if defined(LDDHWSPI) & defined(@LDDHWSPI@OnBlockReceived)
%include Common\GeneralInternal.inc (OnBlockReceived)
void %@LDDHWSPI@OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Calling inherited event */
%ifdef OnBlockReceived
  %OnBlockReceived(UserDataPtr);
%else
  (void)UserDataPtr; /* unused */
%endif %-OnBlockReceived
  %'ModuleName'%.DataReceivedFlag=TRUE;
}

%endif %- @LDDHWSPI@OnBlockReceived
%-INHERITED_EVENT_END LDDHWSPI OnBlockReceived
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%IMPLEMENTATION OnIdle
%include Common\SD_CardOnIdle.Inc
void %OnIdle(void)
{
  /* Write your code here ... */
}

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%include Common\SD_CardOnError.Inc
void %OnError(void)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnActivate
%ifdef OnActivate
%IMPLEMENTATION OnActivate
%define! Parmode
%include Common\SD_CardOnActivate.Inc
void %OnActivate(byte mode)
{
  /* Write your code here ... */
}

%endif %- OnActivate
%-BW_METHOD_END OnActivate
%-BW_METHOD_BEGIN OnDeactivate
%ifdef OnDeactivate
%IMPLEMENTATION OnDeactivate
%define! Parmode
%include Common\SD_CardOnDeactivate.Inc
void %OnDeactivate(byte mode)
{
  /* Write your code here ... */
}

%endif %- OnDeactivate
%-BW_METHOD_END OnDeactivate

%-BW_METHOD_BEGIN OnBlockReceived
%ifdef OnBlockReceived
%IMPLEMENTATION OnBlockReceived
%define! ParUserDataPtr
%include Common\SD_CardOnBlockReceived.Inc
void %OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnBlockReceived
%-BW_METHOD_END OnBlockReceived
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
