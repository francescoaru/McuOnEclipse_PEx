%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    27.08.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef RuntimeCntrLDD
  %ifdef @RuntimeCntrLDD@OnCounterRestart
    %define! Description_%@RuntimeCntrLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntrLDD@OnCounterRestart
%endif %- RuntimeCntrLDD
%ifdef RuntimeCntr
  %ifdef @RuntimeCntr@OnInterrupt
    %define! Description_%@RuntimeCntr@OnInterrupt When a timer interrupt occurs this event is called (only when the component is enabled - <a href="TimerIntMethods.html#Enable">Enable</a> and the events are enabled - <a href="TimerIntMethods.html#EnableEvent">EnableEvent</a>). This event is enabled only if a <a href="TimerIntProperties.html#IntService">interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntr@OnInterrupt
%endif %- RuntimeCntr
%ifdef TickCntr
  %ifdef @TickCntr@OnInterrupt
    %define! Description_%@TickCntr@OnInterrupt This event is called when a compare matches the counter value (if compare or reload is selected as a interrupt source) or a counter overflows (for free-running devices). It is valid only when the component is enabled - <a href="FreeCntrMethods.html#Enable">"Enable"</a> and the events are enabled - <a href="FreeCntrMethods.html#EnableEvent">"EnableEvent"</a>. The event is available only if <a href="FreeCntrProperties.html#IntService">Interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickCntr@OnInterrupt
%endif %- TickCntr
%ifdef TickTimerLDD
  %ifdef @TickTimerLDD@OnCounterRestart
    %define! Description_%@TickTimerLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickTimerLDD@OnCounterRestart
%endif %- TickTimerLDD
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%include freeRTOS_Files.prg
%if defined(myDummy) %- dummy reference to the RTOS adaptor, otherwise the classic Component wizard will NOT include the file below in the package!
%include sw\RTOSAdaptor\FreeRTOS_RTOSAdaptor.prg
%endif
%-
%INTERFACE
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include "FreeRTOS.h"
#include "task.h"                                                %>40/* task API */
#include "semphr.h"                                              %>40/* semaphore API */
#include "event_groups.h"                                        %>40/* event group API */
#include "timers.h"                                              %>40/* timer module API */
#include <stddef.h>                                              %>40/* for size_t type */

/* Macro for shell support */
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED                     %>45 1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED                     %>45 0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand
%if defined(GenerateRTOSPExMacros) & %GenerateRTOSPExMacros='no'
#define %'ModuleName'%.GENERATE_PEX_RTOS_MACROS                  %>45 0  /* set to 1 to generate the RTOS macros PEX_RTOS_INIT() and PEX_RTOS_START() */
%else
#define %'ModuleName'%.GENERATE_PEX_RTOS_MACROS                  %>45 1  /* set to 1 to generate the RTOS macros PEX_RTOS_INIT() and PEX_RTOS_START() */
%endif

/* Macros used by Processor Expert */
#if %'ModuleName'%.GENERATE_PEX_RTOS_MACROS
  #define PEX_RTOS_INIT() /* macro called from PE_low_level_init() */ \
  %if %DisabledInterruptsInStartup='yes'
                                                                 %>>portDISABLE_ALL_INTERRUPTS(); /* disable all interrupts, they get enabled in vStartScheduler() */ \
  %else
                                                                 %>>/* RTOS adapter is configured not to disable interrupts */ \
  %endif
  %if %UseTraceHooksGroup='yes'
                                                                 %>>%@FRTrace@'ModuleName'%.vTraceInitTraceData();/* initialize trace first, as needed by RTOS functions */
  %else
                                                                 %>>/* not Trace Hooks, nothing to do */
  %endif
  #define PEX_RTOS_START()                                       %>>%'ModuleName'%.%vTaskStartScheduler()
#endif
/* macro to identify CPU: 0 for M0+ and 4 for M4 */
%if %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'yes' %- Note: for IAR this is defined in portasm.s too!
#define FREERTOS_CPU_CORTEX_M                                    %>>0 /* Cortex M0+ core */
%else
#define FREERTOS_CPU_CORTEX_M                                    %>>4 /* Cortex M4 core */
%endif
%- =============================================================================
%- Add linker Entry Point - through .xlkr file
%- =============================================================================
%- %define_prj! PE_G_4PEx_ToolChain_Linker_EntryPoint __boot
%-
%- =============================================================================
%- Add other compiler language parameters - through .xlkr file
%- Currently disabled and fixed in source code.
%- =============================================================================
%if Compiler = 'CodeWarriorARM'
  %-if defined(XLKR_C_COMPILER_OTHER_PARAMS)
    %-error! xx %XLKR_C_COMPILER_OTHER_PARAMS
%-    %define_prj! PE_G_4PEx_ToolChain_Compiler_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
  %-if defined(XLKR_ASM_COMPILER_OTHER_PARAMS)
%-    %define_prj! PE_G_4PEx_ToolChain_Asm_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
%endif
%- Hints from Petr Uhlir:
%-1)        You can automatically detect core type by
%-  %if %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'no'
%-    %define! mqx_core M4
%-  %elif %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'yes'
%-    %define! mqx_core M0
%-  %else
%-    %error! Unsupported core platform!
%-  %endif
%-
%-2)        Detect FPU
%-%if %CPUDB_prph_has_feature(CPU, FPU) = 'yes'
%-#define MCU_HAS_FPU                                            %>>1
%-%else
%-#define MCU_HAS_FPU                                            %>>0
%-%endif
%-
%-
%if (CPUfamily = "Kinetis")
%- =============================================================================
%- Allocation of interrupt vectors by RTOS.
%- =============================================================================

/* Prototypes for interrupt service handlers */
void vPortSVCHandler(void);
void vPortPendSVHandler(void);
void vPortTickHandler(void);
%-
%if (defined(PEversionDecimal) && (PEversionDecimal >=0 '1282')) %- this is only supported with MCU 10.3
%- Get interrupts info from CPU database
%- Note: this is done only for Kinetis for now, and defaults are disabled in FreeRTOS_RTOSAdaptor.prg.
%:tmp = %CPUDB_define_Interrupt_Vectors_info()
%-
 %for vect from InterruptVectors
   %if %"%'vect'" = 'defaultInt'
     %if vect = 'ivINT_SVCall'
       %define_prj %'vect' vPortSVCHandler
     %elif vect = 'ivINT_PendableSrvReq'
       %define_prj %'vect' vPortPendSVHandler
     %elif defined(useARMLowPowerTimer) & useARMLowPowerTimer='yes' & vect = 'ivINT_LPTimer'
       %define_prj %'vect' vPortTickHandler
     %elif defined(useARMSysTickTimer) & useARMSysTickTimer='yes' & defined(useARMLowPowerTimer) & useARMLowPowerTimer='no' & vect = 'ivINT_SysTick'
       %define_prj %'vect' vPortTickHandler
     %else
       %- keep PEx default
     %endif
   %endif
 %endfor
%-
%endif %- MCU 10.3
%-
%endif %-(CPUfamily = "Kinetis")
%- =============================================================================
%- Required update of the generated linker command file.
%- =============================================================================
%- DATA SECTION
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  *(.kernel_data)
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_START = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = __KERNEL_DATA_START + 0x0400;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_END = .;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component END */
%- CODE SECTION
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  * (KERNEL)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __VECTOR_TABLE_START = __vector_table;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.rdata)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.exception)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_start__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* EXCEPTION */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_end__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __sinit__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* STATICINIT */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component END */
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_Tsize_t
#define __BWUserType_Tsize_t
  typedef size_t Tsize_t;                                        %>40/* Alias to size_t standard type */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate

#define %'ModuleName'%.%xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask) \
        xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask)
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
#define %'ModuleName'%.%vTaskDelete(pxTask) \
        vTaskDelete(pxTask)
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
#define %'ModuleName'%.%vTaskStartScheduler() \
  vTaskStartScheduler()
%include Common\FreeRTOSvTaskStartScheduler.Inc

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
#define %'ModuleName'%.%taskYIELD() \
  taskYIELD()
%include Common\FreeRTOStaskYIELD.Inc

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
#define %'ModuleName'%.%taskENTER_CRITICAL() \
  taskENTER_CRITICAL()
%include Common\FreeRTOStaskENTER_CRITICAL.Inc

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
#define %'ModuleName'%.%taskEXIT_CRITICAL() \
  taskEXIT_CRITICAL()
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
#define %'ModuleName'%.%taskDISABLE_INTERRUPTS() \
  taskDISABLE_INTERRUPTS()
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
#define %'ModuleName'%.%taskENABLE_INTERRUPTS() \
  taskENABLE_INTERRUPTS()
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
#define %'ModuleName'%.%vTaskEndScheduler() \
  vTaskEndScheduler()
%include Common\FreeRTOSvTaskEndScheduler.Inc

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
#define %'ModuleName'%.%vTaskSuspendAll() \
  vTaskSuspendAll()
%include Common\FreeRTOSvTaskSuspendAll.Inc

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
#define %'ModuleName'%.%xTaskResumeAll() \
  xTaskResumeAll()
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
#define %'ModuleName'%.%vTaskDelay(xTicksToDelay) \
  vTaskDelay(xTicksToDelay)
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
#define %'ModuleName'%.%vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement) \
  vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement)
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
#define %'ModuleName'%.%uxTaskPriorityGet(pxTask) \
  uxTaskPriorityGet(pxTask)
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
#define %'ModuleName'%.%vTaskPrioritySet(pxTask, uxNewPriority) \
  vTaskPrioritySet(pxTask, uxNewPriority)
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
#define %'ModuleName'%.%xSemaphoreTakeRecursive(xMutex, xBlockTime) \
  xSemaphoreTakeRecursive(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
#define %'ModuleName'%.%xSemaphoreGiveRecursive(xMutex) \
  xSemaphoreGiveRecursive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
#define %'ModuleName'%.%xSemaphoreCreateRecursiveMutex() \
  xSemaphoreCreateRecursiveMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
#define %'ModuleName'%.%vTaskSuspend(pxTaskToSuspend) \
  vTaskSuspend(pxTaskToSuspend)

%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
#define %'ModuleName'%.%vTaskResume(pxTaskToResume) \
  vTaskResume(pxTaskToResume)

%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
#define %'ModuleName'%.%xSemaphoreCreateMutex() \
  xSemaphoreCreateMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
#define %'ModuleName'%.%xSemaphoreTake(xMutex, xBlockTime) \
  xSemaphoreTake(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
#define %'ModuleName'%.%xSemaphoreGive(xMutex) \
  xSemaphoreGive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
#define %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphore) \
  vSemaphoreCreateBinary(xSemaphore)

%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
#define %'ModuleName'%.%xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \
  xSemaphoreCreateCounting(uxMaxCount, uxInitialCount)

%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
#define %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
#define %'ModuleName'%.%vSemaphoreDelete(xSemaphore) \
  vSemaphoreDelete(xSemaphore)
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
#define %'ModuleName'%.%vTaskList(pcWriteBuffer, bufSize) \
  vTaskList(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
#define %'ModuleName'%.%pvPortMalloc(xWantedSize) \
  pvPortMalloc(xWantedSize)
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
#define %'ModuleName'%.%vPortFree(pv) \
  vPortFree(pv)
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
#define %'ModuleName'%.%xTaskGetTickCount() \
  xTaskGetTickCount()
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
#define %'ModuleName'%.%xTaskGetSchedulerState() \
  xTaskGetSchedulerState()
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
#define %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTask) \
  uxTaskGetStackHighWaterMark(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
#define %'ModuleName'%.%uxTaskGetNumberOfTasks() \
  uxTaskGetNumberOfTasks()
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
#define %'ModuleName'%.%vTaskGetRunTimeStats(pcWriteBuffer, bufSize) \
  vTaskGetRunTimeStats(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
extern dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntr@OnInterrupt(void);

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
#define %'ModuleName'%.%xPortGetFreeHeapSize() \
  xPortGetFreeHeapSize()

%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
#define %'ModuleName'%.%xQueueCreate(uxQueueLength, uxItemSize) \
  xQueueCreate(uxQueueLength, uxItemSize)
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
#define %'ModuleName'%.%xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
#define %'ModuleName'%.%xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
#define %'ModuleName'%.%xQueueReceive(xQueue, pvBuffer, xTicksToWait) \
  xQueueReceive(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
#define %'ModuleName'%.%xQueuePeek(xQueue, pvBuffer, xTicksToWait) \
  xQueuePeek(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
#define %'ModuleName'%.%vQueueDelete(pxQueueToDelete) \
  vQueueDelete(pxQueueToDelete)
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
#define %'ModuleName'%.%uxQueueMessagesWaiting(xQueue) \
  uxQueueMessagesWaiting(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
#define %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueue) \
  uxQueueMessagesWaitingfromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceiveFromISR
%ifdef xQueueReceiveFromISR
#define %'ModuleName'%.%xQueueReceivefromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken) \
  xQueueReceiveFromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceiveFromISR.Inc

%endif %- xQueueReceiveFromISR
%-BW_METHOD_END xQueueReceiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
#define %'ModuleName'%.%xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) \
  xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
#define %'ModuleName'%.%xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken) \
  xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc

%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
#define %'ModuleName'%.%xTaskResumeFromISR(pxTaskToResume) \
  xTaskResumeFromISR(pxTaskToResume)

%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
extern dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
extern LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
void %@TickCntr@OnInterrupt(void);

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
#define %'ModuleName'%.%xQueueReset(xQueue) \
  xQueueReset(xQueue)

%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
#define %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphore) \
  xSemaphoreGetMutexHolder(xSemaphore)

%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
#define %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FreeRTOSInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetApplicationTaskTag
%ifdef xTaskGetApplicationTaskTag
#define %'ModuleName'%.%xTaskGetApplicationTaskTag(xTask) \
  xTaskGetApplicationTaskTag(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskGetApplicationTaskTag.Inc

%endif %- xTaskGetApplicationTaskTag
%-BW_METHOD_END xTaskGetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetApplicationTaskTag
%ifdef vTaskSetApplicationTaskTag
#define %'ModuleName'%.%vTaskSetApplicationTaskTag(xTask, pxHookFunction) \
  vTaskSetApplicationTaskTag(xTask, pxHookFunction)
%define! ParxTask
%define! ParpxHookFunction
%define! ParVariable_1
%include Common\FreeRTOSvTaskSetApplicationTaskTag.Inc

%endif %- vTaskSetApplicationTaskTag
%-BW_METHOD_END vTaskSetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetCurrentTaskHandle
%ifdef xTaskGetCurrentTaskHandle
#define %'ModuleName'%.%xTaskGetCurrentTaskHandle() \
  xTaskGetCurrentTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTaskGetCurrentTaskHandle.Inc

%endif %- xTaskGetCurrentTaskHandle
%-BW_METHOD_END xTaskGetCurrentTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetIdleTaskHandle
%ifdef xTaskGetIdleTaskHandle
#define %'ModuleName'%.%xTaskGetIdleTaskHandle() \
  xTaskGetIdleTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTaskGetIdleTaskHandle.Inc

%endif %- xTaskGetIdleTaskHandle
%-BW_METHOD_END xTaskGetIdleTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN eTaskGetState
%ifdef eTaskGetState
#define %'ModuleName'%.%eTaskGetState(xTask) \
  eTaskGetState(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSeTaskGetState.Inc

%endif %- eTaskGetState
%-BW_METHOD_END eTaskGetState
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetTaskName
%ifdef pcTaskGetTaskName
#define %'ModuleName'%.%pcTaskGetTaskName(xTaskToQuery) \
  pcTaskGetTaskName(xTaskToQuery)
%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetTaskName.Inc

%endif %- pcTaskGetTaskName
%-BW_METHOD_END pcTaskGetTaskName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCountFromISR
%ifdef xTaskGetTickCountFromISR
#define %'ModuleName'%.%xTaskGetTickCountFromISR() \
  xTaskGetTickCountFromISR()
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCountFromISR.Inc

%endif %- xTaskGetTickCountFromISR
%-BW_METHOD_END xTaskGetTickCountFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCallApplicationTaskHook
%ifdef xTaskCallApplicationTaskHook
#define %'ModuleName'%.%xTaskCallApplicationTaskHook(xTask, pvParameter) \
  xTaskCallApplicationTaskHook(xTask, pvParameter)
%define! ParxTask
%define! ParpvParameter
%define! RetVal
%include Common\FreeRTOSxTaskCallApplicationTaskHook.Inc

%endif %- xTaskCallApplicationTaskHook
%-BW_METHOD_END xTaskCallApplicationTaskHook
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStepTick
%ifdef vTaskStepTick
#define %'ModuleName'%.%vTaskStepTick(xTicksToJump) \
  vTaskStepTick(xTicksToJump)
%define! ParxTicksToJump
%include Common\FreeRTOSvTaskStepTick.Inc

%endif %- vTaskStepTick
%-BW_METHOD_END vTaskStepTick
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeekFromISR
%ifdef xQueuePeekFromISR
#define %'ModuleName'%.%xQueuePeekFromISR(xQueue, pvBuffer, xTicksToWait) \
  xQueuePeekFromISR(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeekFromISR.Inc

%endif %- xQueuePeekFromISR
%-BW_METHOD_END xQueuePeekFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwrite
%ifdef xQueueOverwrite
#define %'ModuleName'%.%xQueueOverwrite(xQueue, pvItemToQueue) \
  xQueueOverwrite(xQueue, pvItemToQueue)
%define! ParxQueue
%define! ParpvItemToQueue
%define! RetVal
%include Common\FreeRTOSxQueueOverwrite.Inc

%endif %- xQueueOverwrite
%-BW_METHOD_END xQueueOverwrite
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwriteFromISR
%ifdef xQueueOverwriteFromISR
#define %'ModuleName'%.%xQueueOverwriteFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) \
  xQueueOverwriteFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueOverwriteFromISR.Inc

%endif %- xQueueOverwriteFromISR
%-BW_METHOD_END xQueueOverwriteFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueAddToRegistry
%ifdef vQueueAddToRegistry
#define %'ModuleName'%.%vQueueAddToRegistry(xQueue, pcQueueName) \
  vQueueAddToRegistry(xQueue, pcQueueName)
%define! ParxQueue
%define! ParpcQueueName
%include Common\FreeRTOSvQueueAddToRegistry.Inc

%endif %- vQueueAddToRegistry
%-BW_METHOD_END vQueueAddToRegistry
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueUnregisterQueue
%ifdef vQueueUnregisterQueue
#define %'ModuleName'%.%vQueueUnregisterQueue(xQueue) \
  vQueueUnregisterQueue(xQueue)
%define! ParxQueue
%include Common\FreeRTOSvQueueUnregisterQueue.Inc

%endif %- vQueueUnregisterQueue
%-BW_METHOD_END vQueueUnregisterQueue
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueFullFromISR
%ifdef xQueueIsQueueFullFromISR
#define %'ModuleName'%.%xQueueIsQueueFullFromISR(xQueue) \
  xQueueIsQueueFullFromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueFullFromISR.Inc

%endif %- xQueueIsQueueFullFromISR
%-BW_METHOD_END xQueueIsQueueFullFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueEmptyFromISR
%ifdef xQueueIsQueueEmptyFromISR
#define %'ModuleName'%.%xQueueIsQueueEmptyFromISR(xQueue) \
  xQueueIsQueueEmptyFromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueEmptyFromISR.Inc

%endif %- xQueueIsQueueEmptyFromISR
%-BW_METHOD_END xQueueIsQueueEmptyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueAddToSet
%ifdef xQueueAddToSet
#define %'ModuleName'%.%xQueueAddToSet(xQueueOrSemaphore, xQueueSet) \
  xQueueAddToSet(xQueueOrSemaphore, xQueueSet)
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueAddToSet.Inc

%endif %- xQueueAddToSet
%-BW_METHOD_END xQueueAddToSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateSet
%ifdef xQueueCreateSet
#define %'ModuleName'%.%xQueueCreateSet(uxEventQueueLength) \
  xQueueCreateSet(uxEventQueueLength)
%define! ParuxEventQueueLength
%define! RetVal
%include Common\FreeRTOSxQueueCreateSet.Inc

%endif %- xQueueCreateSet
%-BW_METHOD_END xQueueCreateSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueRemoveFromSet
%ifdef xQueueRemoveFromSet
#define %'ModuleName'%.%xQueueRemoveFromSet(xQueueOrSemaphore, xQueueSet) \
  xQueueRemoveFromSet(xQueueOrSemaphore, xQueueSet)
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueRemoveFromSet.Inc

%endif %- xQueueRemoveFromSet
%-BW_METHOD_END xQueueRemoveFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSet
%ifdef xQueueSelectFromSet
#define %'ModuleName'%.%xQueueSelectFromSet(xQueueSet, xBlockTimeTicks) \
  xQueueSelectFromSet(xQueueSet, xBlockTimeTicks)
%define! ParxQueueSet
%define! ParxBlockTimeTicks
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSet.Inc

%endif %- xQueueSelectFromSet
%-BW_METHOD_END xQueueSelectFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSetFromISR
%ifdef xQueueSelectFromSetFromISR
#define %'ModuleName'%.%xQueueSelectFromSetFromISR(xQueueSet) \
  xQueueSelectFromSetFromISR(xQueueSet)
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSetFromISR.Inc

%endif %- xQueueSelectFromSetFromISR
%-BW_METHOD_END xQueueSelectFromSetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreate
%ifdef xEventGroupCreate
#define %'ModuleName'%.%xEventGroupCreate() \
  xEventGroupCreate()
%define! RetVal
%include Common\FreeRTOSxEventGroupCreate.Inc

%endif %- xEventGroupCreate
%-BW_METHOD_END xEventGroupCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupWaitBits
%ifdef xEventGroupWaitBits
#define %'ModuleName'%.%xEventGroupWaitBits(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait) \
  xEventGroupWaitBits(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait)
%define! ParxEventGroup
%define! ParuxBitsToWaitFor
%define! ParxClearOnExit
%define! ParxWaitForAllBits
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupWaitBits.Inc

%endif %- xEventGroupWaitBits
%-BW_METHOD_END xEventGroupWaitBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBits
%ifdef xEventGroupSetBits
#define %'ModuleName'%.%xEventGroupSetBits(xEventGroup, uxBitsToSet) \
  xEventGroupSetBits(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBits.Inc

%endif %- xEventGroupSetBits
%-BW_METHOD_END xEventGroupSetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBitsFromISR
%ifdef xEventGroupSetBitsFromISR
#define %'ModuleName'%.%xEventGroupSetBitsFromISR(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken) \
  xEventGroupSetBitsFromISR(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBitsFromISR.Inc

%endif %- xEventGroupSetBitsFromISR
%-BW_METHOD_END xEventGroupSetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBits
%ifdef xEventGroupClearBits
#define %'ModuleName'%.%xEventGroupClearBits(xEventGroup, uxBitsToSet) \
  xEventGroupClearBits(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBits.Inc

%endif %- xEventGroupClearBits
%-BW_METHOD_END xEventGroupClearBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBitsFromISR
%ifdef xEventGroupClearBitsFromISR
#define %'ModuleName'%.%xEventGroupClearBitsFromISR(xEventGroup, uxBitsToSet) \
  xEventGroupClearBitsFromISR(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBitsFromISR.Inc

%endif %- xEventGroupClearBitsFromISR
%-BW_METHOD_END xEventGroupClearBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBits
%ifdef xEventGroupGetBits
#define %'ModuleName'%.%xEventGroupGetBits(xEventGroup) \
  xEventGroupGetBits(xEventGroup)
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBits.Inc

%endif %- xEventGroupGetBits
%-BW_METHOD_END xEventGroupGetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBitsFromISR
%ifdef xEventGroupGetBitsFromISR
#define %'ModuleName'%.%xEventGroupGetBitsFromISR(xEventGroup) \
  xEventGroupGetBitsFromISR(xEventGroup)
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBitsFromISR.Inc

%endif %- xEventGroupGetBitsFromISR
%-BW_METHOD_END xEventGroupGetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSync
%ifdef xEventGroupSync
#define %'ModuleName'%.%xEventGroupSync(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait) \
  xEventGroupSync(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParuxBitsToWaitFor
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupSync.Inc

%endif %- xEventGroupSync
%-BW_METHOD_END xEventGroupSync
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreate
%ifdef xTimerCreate
#define %'ModuleName'%.%xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction) \
  xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction)
%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! RetVal
%include Common\FreeRTOSxTimerCreate.Inc

%endif %- xTimerCreate
%-BW_METHOD_END xTimerCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerIsTimerActive
%ifdef xTimerIsTimerActive
#define %'ModuleName'%.%xTimerIsTimerActive(xTimer) \
  xTimerIsTimerActive(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerIsTimerActive.Inc

%endif %- xTimerIsTimerActive
%-BW_METHOD_END xTimerIsTimerActive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStart
%ifdef xTimerStart
#define %'ModuleName'%.%xTimerStart(xTimer, xBlockTime) \
  xTimerStart(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStart.Inc

%endif %- xTimerStart
%-BW_METHOD_END xTimerStart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStop
%ifdef xTimerStop
#define %'ModuleName'%.%xTimerStop(xTimer, xBlockTime) \
  xTimerStop(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStop.Inc

%endif %- xTimerStop
%-BW_METHOD_END xTimerStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriod
%ifdef xTimerChangePeriod
#define %'ModuleName'%.%xTimerChangePeriod(xTimer, xNewPeriod, xBlockTime) \
  xTimerChangePeriod(xTimer, xNewPeriod, xBlockTime)
%define! ParxTimer
%define! ParxNewPeriod
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriod.Inc

%endif %- xTimerChangePeriod
%-BW_METHOD_END xTimerChangePeriod
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerDelete
%ifdef xTimerDelete
#define %'ModuleName'%.%xTimerDelete(xTimer, xBlockTime) \
  xTimerDelete(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerDelete.Inc

%endif %- xTimerDelete
%-BW_METHOD_END xTimerDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerReset
%ifdef xTimerReset
#define %'ModuleName'%.%xTimerReset(xTimer, xBlockTime) \
  xTimerReset(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerReset.Inc

%endif %- xTimerReset
%-BW_METHOD_END xTimerReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStartFromISR
%ifdef xTimerStartFromISR
#define %'ModuleName'%.%xTimerStartFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerStartFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerStartFromISR.Inc

%endif %- xTimerStartFromISR
%-BW_METHOD_END xTimerStartFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStopFromISR
%ifdef xTimerStopFromISR
#define %'ModuleName'%.%xTimerStopFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerStopFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParpxHigherPriorityTaskWoken
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerStopFromISR.Inc

%endif %- xTimerStopFromISR
%-BW_METHOD_END xTimerStopFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriodFromISR
%ifdef xTimerChangePeriodFromISR
#define %'ModuleName'%.%xTimerChangePeriodFromISR(xTimer, xNewPeriod, pxHigherPriorityTaskWoken) \
  xTimerChangePeriodFromISR(xTimer, xNewPeriod, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParxNewPeriod
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriodFromISR.Inc

%endif %- xTimerChangePeriodFromISR
%-BW_METHOD_END xTimerChangePeriodFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerResetFromISR
%ifdef xTimerResetFromISR
#define %'ModuleName'%.%xTimerResetFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerResetFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerResetFromISR.Inc

%endif %- xTimerResetFromISR
%-BW_METHOD_END xTimerResetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTimerGetTimerID
%ifdef pvTimerGetTimerID
#define %'ModuleName'%.%pvTimerGetTimerID(xTimer) \
  pvTimerGetTimerID(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpvTimerGetTimerID.Inc

%endif %- pvTimerGetTimerID
%-BW_METHOD_END pvTimerGetTimerID
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerGetTimerDaemonTaskHandle
%ifdef xTimerGetTimerDaemonTaskHandle
#define %'ModuleName'%.%xTimerGetTimerDaemonTaskHandle() \
  xTimerGetTimerDaemonTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTimerGetTimerDaemonTaskHandle.Inc

%endif %- xTimerGetTimerDaemonTaskHandle
%-BW_METHOD_END xTimerGetTimerDaemonTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTimerGetTimerName
%ifdef pcTimerGetTimerName
#define %'ModuleName'%.%pcTimerGetTimerName(xTimer) \
  pcTimerGetTimerName(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpcTimerGetTimerName.Inc

%endif %- pcTimerGetTimerName
%-BW_METHOD_END pcTimerGetTimerName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCall
%ifdef xTimerPendFunctionCall
#define %'ModuleName'%.%xTimerPendFunctionCall(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait) \
  xTimerPendFunctionCall(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait)
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCall.Inc

%endif %- xTimerPendFunctionCall
%-BW_METHOD_END xTimerPendFunctionCall
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCallFromISR
%ifdef xTimerPendFunctionCallFromISR
#define %'ModuleName'%.%xTimerPendFunctionCallFromISR(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken) \
  xTimerPendFunctionCallFromISR(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken)
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCallFromISR.Inc

%endif %- xTimerPendFunctionCallFromISR
%-BW_METHOD_END xTimerPendFunctionCallFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyGive
%ifdef xTaskNotifyGive
#define %'ModuleName'%.%xTaskNotifyGive(xTaskToNotify) \
  xTaskNotifyGive(xTaskToNotify) \
%define! ParxTaskToNotify
%define! RetVal
%include Common\FreeRTOSxTaskNotifyGive.Inc

%endif %- xTaskNotifyGive
%-BW_METHOD_END xTaskNotifyGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN ulTaskNotifyTake
%ifdef ulTaskNotifyTake
#define %'ModuleName'%.%ulTaskNotifyTake(xClearCountOnExit, xTicksToWait) \
  ulTaskNotifyTake(xClearCountOnExit, xTicksToWait)
%define! ParxClearCountOnExit
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSulTaskNotifyTake.Inc

%endif %- ulTaskNotifyTake
%-BW_METHOD_END ulTaskNotifyTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskNotifyGiveFromISR
%ifdef vTaskNotifyGiveFromISR
#define %'ModuleName'%.%vTaskNotifyGiveFromISR(xTaskToNotify, pxHigherPriorityTaskWoken) \
  vTaskNotifyGiveFromISR(xTaskToNotify, pxHigherPriorityTaskWoken)
%define! ParxTaskToNotify
%define! ParpxHigherPriorityTaskWoken
%include Common\FreeRTOSvTaskNotifyGiveFromISR.Inc

%endif %- vTaskNotifyGiveFromISR
%-BW_METHOD_END vTaskNotifyGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotify
%ifdef xTaskNotify
#define %'ModuleName'%.%xTaskNotify(xTaskToNotify, ulValue, eAction) \
  xTaskNotify(xTaskToNotify, ulValue, eAction)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! RetVal
%include Common\FreeRTOSxTaskNotify.Inc

%endif %- xTaskNotify
%-BW_METHOD_END xTaskNotify
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyFromISR
%ifdef xTaskNotifyFromISR
#define %'ModuleName'%.%xTaskNotifyFromISR(xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken) \
  xTaskNotifyFromISR(xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyFromISR.Inc

%endif %- xTaskNotifyFromISR
%-BW_METHOD_END xTaskNotifyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyWait
%ifdef xTaskNotifyWait
#define %'ModuleName'%.%xTaskNotifyWait(ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait) \
  xTaskNotifyWait(ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait)
%define! ParulBitsToClearOnEntry
%define! ParulBitsToClearOnExit
%define! ParpulNotificationValue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTaskNotifyWait.Inc

%endif %- xTaskNotifyWait
%-BW_METHOD_END xTaskNotifyWait
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%INTERFACE vApplicationStackOverflowHook
void %vApplicationStackOverflowHook(xTaskHandle pxTask, char *pcTaskName);
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%INTERFACE vApplicationTickHook
void %vApplicationTickHook(void);
%include Common\FreeRTOSvApplicationTickHook.Inc

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%INTERFACE vApplicationIdleHook
void %vApplicationIdleHook(void);
%include Common\FreeRTOSvApplicationIdleHook.Inc

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%INTERFACE vApplicationMallocFailedHook
void %vApplicationMallocFailedHook(void);
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_METHOD_BEGIN vOnPostSleepProcessing
%ifdef vOnPostSleepProcessing
%INTERFACE vOnPostSleepProcessing
void %vOnPostSleepProcessing(portTickType expectedIdleTicks);
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPostSleepProcessing.Inc

%endif %- vOnPostSleepProcessing
%-BW_METHOD_END vOnPostSleepProcessing
%-BW_METHOD_BEGIN vOnPreSleepProcessing
%ifdef vOnPreSleepProcessing
%INTERFACE vOnPreSleepProcessing
void %vOnPreSleepProcessing(portTickType expectedIdleTicks);
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPreSleepProcessing.Inc

%endif %- vOnPreSleepProcessing
%-BW_METHOD_END vOnPreSleepProcessing
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
#include "portTicks.h"                                           %>40/* interface to tick counter */
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if (%CPUfamily = "Kinetis") & (%Compiler = "CodeWarriorARM")
/* The Freescale Kinetis compiler generates different code for the PendSV and PendSVC interrupt handlers in Events.c.
   This requires that different code needs to be used for xPortPendSVHandler() and vPortSVCHandler(). */
#if defined(__optlevel0) || defined(__optlevel1) || defined(__optlevel2) || defined(__optlevel3) || defined(__optlevel4)
  /* Starting with MCU10.2 release, the Kinetis compiler offers the above macros to indicate the optimization level,
     so let's check if we are using the right settings in the FreeRTOS component as well... */
%if %CompilerOptimizationLevel='0'
  #if !defined(__optlevel0) /* FreeRTOS Processor Expert component has set optimization level 0, but compiler has something different? */
%elif %CompilerOptimizationLevel='1'
  #if !defined(__optlevel1) /* FreeRTOS Processor Expert component has set optimization level 1, but compiler has something different? */
%elif %CompilerOptimizationLevel='2'
  #if !defined(__optlevel2) /* FreeRTOS Processor Expert component has set optimization level 2, but compiler has something different? */
%elif %CompilerOptimizationLevel='3'
  #if !defined(__optlevel3) /* FreeRTOS Processor Expert component has set optimization level 3, but compiler has something different? */
%elif %CompilerOptimizationLevel='4'
  #if !defined(__optlevel4) /* FreeRTOS Processor Expert component has set optimization level 4, but compiler has something different? */
%endif
    #error "Mismatch between compiler optimization level and FreeRTOS Processor Expert settings! Please check your compiler and component settings."
  #endif
#endif

%endif
%- NOTE: cannot OR the following two define: MCU6.3 will report an internal error
%if defined(RuntimeCntr) & defined(@RuntimeCntr@OnInterrupt)
dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
%elif defined(RuntimeCntrLDD) & defined(@RuntimeCntrLDD@OnCounterRestart)
dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
%endif

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
#if configUSE_TRACE_FACILITY || configGENERATE_RUN_TIME_STATS /* FreeRTOS trace feature enabled */
#if configFRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *taskListBufferP=NULL; /* allocated only once, never deallocated! */
#else
  unsigned char *taskListBufferP;
#endif
  size_t bufSize;
#endif
  byte buf[16];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

#if configUSE_TRACE_FACILITY /* FreeRTOS trace feature enabled */
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"TASK LIST:\r\nName\t\tState\tPrio\tStack\tTCB#\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if configFRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
  }
#else
  taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
#endif
  if (taskListBufferP != NULL) {
    %'ModuleName'%.vTaskList((char*)taskListBufferP, bufSize);
    %@Shell@'ModuleName'%.SendStr(taskListBufferP, io->stdOut);
#if configFRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %'ModuleName'%.vPortFree(taskListBufferP);
#endif
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
#if ((configGENERATE_RUN_TIME_STATS==1) && (configUSE_STATS_FORMATTING_FUNCTIONS==1))
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\nRTOS RUN-TIME STATISTICS:\r\nName\t\tTime\t\t%%Time\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if configFRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize);
  }
#else
  taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize);
#endif
  if (taskListBufferP != NULL) {
    %'ModuleName'%.vTaskGetRunTimeStats((char*)taskListBufferP, bufSize);
    %@Shell@'ModuleName'%.SendStr(taskListBufferP, io->stdOut);
#if configFRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %'ModuleName'%.vPortFree(taskListBufferP);
#endif
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  RTOS ticks", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" Hz, ", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ms\r\n", io->stdOut);
#if configFRTOS_MEMORY_SCHEME!=3 /* wrapper to malloc() does not have xPortGetFreeHeapSize() */
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Free heap", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), %'ModuleName'%.xPortGetFreeHeapSize());
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" bytes\r\n", io->stdOut);
#endif

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc
/*
void %'ModuleName'%.%vTaskDelete(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
%include Common\FreeRTOSvTaskStartScheduler.Inc
/*
void %'ModuleName'%.%vTaskStartScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
%include Common\FreeRTOStaskYIELD.Inc
/*
void %'ModuleName'%.%taskYIELD(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
%include Common\FreeRTOStaskENTER_CRITICAL.Inc
/*
void %'ModuleName'%.%taskENTER_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc
/*
void %'ModuleName'%.%taskEXIT_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskDISABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskENABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
%include Common\FreeRTOSvTaskEndScheduler.Inc
/*
void %'ModuleName'%.%vTaskEndScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
%include Common\FreeRTOSvTaskSuspendAll.Inc
/*
void %'ModuleName'%.%vTaskSuspendAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeFromISR(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc
/*
void %'ModuleName'%.%vTaskDelay(portTickType xTicksToDelay)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc
/*
void %'ModuleName'%.%vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskPriorityGet(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc
/*
void %'ModuleName'%.%vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateRecursiveMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc
/*
void %'ModuleName'%.%vSemaphoreDelete(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc
/*
void %'ModuleName'%.%vTaskSuspend(xTaskHandle pxTaskToSuspend)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc
/*
void %'ModuleName'%.%vTaskResume(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc
/*
bool %'ModuleName'%.%xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc
/*
void %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc
/*
void %'ModuleName'%.%vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc
/*
pVoid %'ModuleName'%.%pvPortMalloc(size_t xWantedSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc
/*
void %'ModuleName'%.%vPortFree(void *pv)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc
/*
portTickType %'ModuleName'%.%xTaskGetTickCount(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskGetSchedulerState(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetNumberOfTasks(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc
/*
void %'ModuleName'%.%vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@RuntimeCntr@OnInterrupt(void)
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc
/*
Tsize_t %'ModuleName'%.%xPortGetFreeHeapSize(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc
/*
xQueueHandle %'ModuleName'%.%xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc
/*
void %'ModuleName'%.%vQueueDelete(xQueueHandle pxQueueToDelete)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaiting(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceiveFromISR
%ifdef xQueueReceiveFromISR
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceiveFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceiveFromISR
%-BW_METHOD_END xQueueReceiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/
%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
%if (%Compiler = "GNUC")
__attribute__((naked)) void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%elif (%Compiler = "IARARM")
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr) {
%else
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%endif
  vPortTickHandler();
}

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused)))
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
%include Common\GeneralInternal.inc (OnInterrupt)
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08")
#pragma NO_ENTRY /* do not create entry sequence */
#pragma NO_EXIT  /* do not create exit sequence */
#pragma NO_RETURN /* we care about this (RTI) */
%endif
void %@TickCntr@OnInterrupt(void)
{
  /* NOTE: we are called here from the tick interrupt (periodic timer bean, ISR). However, we need to imitate things in
           a way as this function would be the primary ISR (means that this function would have been raised directly by
           the interrupt. In order to do this, we need to to 'fix' the stack below in a rather hacky way :-( */
%if (CPUfamily = "ColdFireV1") | (CPUfamily = "MCF")
  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
    naked                                                        %>40 /* No stack frame or compiler-generated rts */
    LEA     4(A7),A7                                             %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
%if (CPUfamily = "MCF")
%- NOTE: was MOVEM.L 8(A7),D0-D2/A0-A1  for normal periodic tick timer
    MOVEM.L 8(A7),D0-D2/A0-A1                                    %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    UNLK    A6                                                   %>40 /* Unlink instruction (normally done in caller/bean code) */
    ADDQ.L  #4,A7                                                %>40 /* normally done in the caller/bean code */
%else
    MOVEM.L (A7),D0-D2/A0-A1                                     %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    LEA     20(A7),A7                                            %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
%endif
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
    LEA     -24(A7),A7                                           %>40 /* Reserve space for processor registers onto stack */
    MOVEM.L D0-D2/D7/A0-A1,(A7)                                  %>40 /* Save registers */
  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
  asm {
    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
  }
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
  asm { /* need to do this in assembly, otherwise the compiler might use the stack! :-( */
    JSR xTaskIncrementTick  /* return value != 0 (pdFALSE): yield */
    TST D0
    BEQ noYield
  }
  taskYIELD();
  asm {
    noYield:
  }
  asm {
    MOVE.L D7,D0
    JSR ulPortSetIPL
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  /* now generate interrupt exit code */
  asm {
    MOVEM.L    (A7),D0-D2/D7/A0-A1                               %>40 /* Restore processor registers from stack */
    LEA        24(A7),A7                                         %>40 /* Remove space from stack */
    RTE                                                          %>40 /* Return to task or nested ISR */
  }
%elif (CPUfamily = "Kinetis")
  /* Kinetis is using LDD approach */
%elif (CPUfamily = "HCS08") | (CPUfamily = "HC08")
  __asm {
    PULH  ; remove return address from stack (from JSR to this function)
    PULH
#ifdef __BANKED__
    PULH  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#endif
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  #if configUSE_PREEMPTION == 1
    portSAVE_CONTEXT(); /* A context switch might happen so save the context. */
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      vTaskSwitchContext(); /* a context switch is necessary */
    }
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes PULH and RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    (void)xTaskIncrementTick(); /* non-preemptive mode, no context switch */
    __asm("PULH");
    __asm("RTI");
  #endif
%elif (CPUfamily = "HCS12") | (CPUfamily = "HCS12X")
  asm {
#ifdef __BANKED__
    LEAS 3,SP  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#else
    LEAS 2,SP
#endif
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  #if configUSE_PREEMPTION == 1
    portSAVE_CONTEXT(); /* A context switch might happen so save the context. */
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      vTaskSwitchContext(); /* a context switch is necessary */
    }
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    (void)xTaskIncrementTick(); /* non-preemptive mode, no context switch */
    __asm("RTI"); /* return from interrupt */
  #endif
%elif (CPUfamily = "56800")
//  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
//    naked                                                      %>40 /* No stack frame or compiler-generated rts */
//    LEA     4(A7),A7                                           %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
//    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
//    MOVEM.L (A7),D0-D2/A0-A1                                   %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
//    LEA     20(A7),A7                                          %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
//    LEA     -24(A7),A7                                         %>40 /* Reserve space for processor registers onto stack */
//    MOVEM.L D0-D2/D7/A0-A1,(A7)                                %>40 /* Save registers */
//  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
//  asm {
//    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
//  }
  {
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      taskYIELD();
    }
  }
//  asm {
//    MOVE.L D7,D0
//    JSR ulPortSetIPL
//  }

  /* If we are using the pre-emptive scheduler then also request a
     context switch as incrementing the tick could have unblocked a task. */
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  /* now generate interrupt exit code */
//  asm {
//    MOVEM.L    (A7),D0-D2/D7/A0-A1                             %>40 /* Restore processor registers from stack */
//    LEA        24(A7),A7                                       %>40 /* Remove space from stack */
//    RTE                                                        %>40 /* Return to task or nested ISR */
//  }
%else
  #error "CPU %CPUfamily not supported"
%endif
}

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReset(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc
/*
void* %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FreeRTOSInit.Inc
void %'ModuleName'%.%Init(void)
{
  vPortInitTickTimer();
  vPortStopTickTimer();
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetApplicationTaskTag
%ifdef xTaskGetApplicationTaskTag
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskGetApplicationTaskTag.Inc
/*
pdTASK_HOOK_CODE %'ModuleName'%.%xTaskGetApplicationTaskTag(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetApplicationTaskTag
%-BW_METHOD_END xTaskGetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetApplicationTaskTag
%ifdef vTaskSetApplicationTaskTag
%define! ParxTask
%define! ParpxHookFunction
%define! ParVariable_1
%include Common\FreeRTOSvTaskSetApplicationTaskTag.Inc
/*
void %'ModuleName'%.%vTaskSetApplicationTaskTag(xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction, byte Variable_1)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSetApplicationTaskTag
%-BW_METHOD_END vTaskSetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetCurrentTaskHandle
%ifdef xTaskGetCurrentTaskHandle
%define! RetVal
%include Common\FreeRTOSxTaskGetCurrentTaskHandle.Inc
/*
xTaskHandle %'ModuleName'%.%xTaskGetCurrentTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetCurrentTaskHandle
%-BW_METHOD_END xTaskGetCurrentTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetIdleTaskHandle
%ifdef xTaskGetIdleTaskHandle
%define! RetVal
%include Common\FreeRTOSxTaskGetIdleTaskHandle.Inc
/*
xTaskHandle %'ModuleName'%.%xTaskGetIdleTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetIdleTaskHandle
%-BW_METHOD_END xTaskGetIdleTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN eTaskGetState
%ifdef eTaskGetState
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSeTaskGetState.Inc
/*
eTaskState %'ModuleName'%.%eTaskGetState(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- eTaskGetState
%-BW_METHOD_END eTaskGetState
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetTaskName
%ifdef pcTaskGetTaskName
%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetTaskName.Inc
/*
signed char %'ModuleName'%.%pcTaskGetTaskName(xTaskHandle xTaskToQuery)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pcTaskGetTaskName
%-BW_METHOD_END pcTaskGetTaskName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCountFromISR
%ifdef xTaskGetTickCountFromISR
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCountFromISR.Inc
/*
portTickType %'ModuleName'%.%xTaskGetTickCountFromISR(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetTickCountFromISR
%-BW_METHOD_END xTaskGetTickCountFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCallApplicationTaskHook
%ifdef xTaskCallApplicationTaskHook
%define! ParxTask
%define! ParpvParameter
%define! RetVal
%include Common\FreeRTOSxTaskCallApplicationTaskHook.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskCallApplicationTaskHook(xTaskHandle xTask, void* pvParameter)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCallApplicationTaskHook
%-BW_METHOD_END xTaskCallApplicationTaskHook
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStepTick
%ifdef vTaskStepTick
%define! ParxTicksToJump
%include Common\FreeRTOSvTaskStepTick.Inc
/*
void %'ModuleName'%.%vTaskStepTick(portTickType xTicksToJump)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskStepTick
%-BW_METHOD_END vTaskStepTick
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeekFromISR
%ifdef xQueuePeekFromISR
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeekFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueuePeekFromISR(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueuePeekFromISR
%-BW_METHOD_END xQueuePeekFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwrite
%ifdef xQueueOverwrite
%define! ParxQueue
%define! ParpvItemToQueue
%define! RetVal
%include Common\FreeRTOSxQueueOverwrite.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueOverwrite(xQueueHandle xQueue, const void *pvItemToQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueOverwrite
%-BW_METHOD_END xQueueOverwrite
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwriteFromISR
%ifdef xQueueOverwriteFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueOverwriteFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueOverwriteFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueOverwriteFromISR
%-BW_METHOD_END xQueueOverwriteFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueAddToRegistry
%ifdef vQueueAddToRegistry
%define! ParxQueue
%define! ParpcQueueName
%include Common\FreeRTOSvQueueAddToRegistry.Inc
/*
void %'ModuleName'%.%vQueueAddToRegistry(xQueueHandle xQueue, char *pcQueueName)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueAddToRegistry
%-BW_METHOD_END vQueueAddToRegistry
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueUnregisterQueue
%ifdef vQueueUnregisterQueue
%define! ParxQueue
%include Common\FreeRTOSvQueueUnregisterQueue.Inc
/*
void %'ModuleName'%.%vQueueUnregisterQueue(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueUnregisterQueue
%-BW_METHOD_END vQueueUnregisterQueue
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueFullFromISR
%ifdef xQueueIsQueueFullFromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueFullFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueIsQueueFullFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueIsQueueFullFromISR
%-BW_METHOD_END xQueueIsQueueFullFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueEmptyFromISR
%ifdef xQueueIsQueueEmptyFromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueEmptyFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueIsQueueEmptyFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueIsQueueEmptyFromISR
%-BW_METHOD_END xQueueIsQueueEmptyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueAddToSet
%ifdef xQueueAddToSet
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueAddToSet.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueAddToSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueAddToSet
%-BW_METHOD_END xQueueAddToSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateSet
%ifdef xQueueCreateSet
%define! ParuxEventQueueLength
%define! RetVal
%include Common\FreeRTOSxQueueCreateSet.Inc
/*
xQueueSetHandle %'ModuleName'%.%xQueueCreateSet(unsigned portBASE_TYPE uxEventQueueLength)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreateSet
%-BW_METHOD_END xQueueCreateSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueRemoveFromSet
%ifdef xQueueRemoveFromSet
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueRemoveFromSet.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueRemoveFromSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueRemoveFromSet
%-BW_METHOD_END xQueueRemoveFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSet
%ifdef xQueueSelectFromSet
%define! ParxQueueSet
%define! ParxBlockTimeTicks
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSet.Inc
/*
xQueueSetMemberHandle %'ModuleName'%.%xQueueSelectFromSet(xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSelectFromSet
%-BW_METHOD_END xQueueSelectFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSetFromISR
%ifdef xQueueSelectFromSetFromISR
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSetFromISR.Inc
/*
xQueueSetMemberHandle %'ModuleName'%.%xQueueSelectFromSetFromISR(xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSelectFromSetFromISR
%-BW_METHOD_END xQueueSelectFromSetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreate
%ifdef xEventGroupCreate
%define! RetVal
%include Common\FreeRTOSxEventGroupCreate.Inc
/*
EventGroupHandle_t %'ModuleName'%.%xEventGroupCreate(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupCreate
%-BW_METHOD_END xEventGroupCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupWaitBits
%ifdef xEventGroupWaitBits
%define! ParxEventGroup
%define! ParuxBitsToWaitFor
%define! ParxClearOnExit
%define! ParxWaitForAllBits
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupWaitBits.Inc
/*
byte %'ModuleName'%.%xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupWaitBits
%-BW_METHOD_END xEventGroupWaitBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBits
%ifdef xEventGroupSetBits
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSetBits
%-BW_METHOD_END xEventGroupSetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBitsFromISR
%ifdef xEventGroupSetBitsFromISR
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet , BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSetBitsFromISR
%-BW_METHOD_END xEventGroupSetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBits
%ifdef xEventGroupClearBits
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupClearBits
%-BW_METHOD_END xEventGroupClearBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBitsFromISR
%ifdef xEventGroupClearBitsFromISR
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupClearBitsFromISR
%-BW_METHOD_END xEventGroupClearBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBits
%ifdef xEventGroupGetBits
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupGetBits(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupGetBits
%-BW_METHOD_END xEventGroupGetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBitsFromISR
%ifdef xEventGroupGetBitsFromISR
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupGetBitsFromISR
%-BW_METHOD_END xEventGroupGetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSync
%ifdef xEventGroupSync
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParuxBitsToWaitFor
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupSync.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSync
%-BW_METHOD_END xEventGroupSync
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreate
%ifdef xTimerCreate
%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! RetVal
%include Common\FreeRTOSxTimerCreate.Inc
/*
TimerHandle_t %'ModuleName'%.%xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerCreate
%-BW_METHOD_END xTimerCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerIsTimerActive
%ifdef xTimerIsTimerActive
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerIsTimerActive.Inc
/*
BaseType_t %'ModuleName'%.%xTimerIsTimerActive(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerIsTimerActive
%-BW_METHOD_END xTimerIsTimerActive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStart
%ifdef xTimerStart
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStart.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStart(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStart
%-BW_METHOD_END xTimerStart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStop
%ifdef xTimerStop
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStop.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStop(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStop
%-BW_METHOD_END xTimerStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriod
%ifdef xTimerChangePeriod
%define! ParxTimer
%define! ParxNewPeriod
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriod.Inc
/*
BaseType_t %'ModuleName'%.%xTimerChangePeriod(TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerChangePeriod
%-BW_METHOD_END xTimerChangePeriod
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerDelete
%ifdef xTimerDelete
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerDelete.Inc
/*
BaseType_t %'ModuleName'%.%xTimerDelete(TickType_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerDelete
%-BW_METHOD_END xTimerDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerReset
%ifdef xTimerReset
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerReset.Inc
/*
BaseType_t %'ModuleName'%.%xTimerReset(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerReset
%-BW_METHOD_END xTimerReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStartFromISR
%ifdef xTimerStartFromISR
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerStartFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStartFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStartFromISR
%-BW_METHOD_END xTimerStartFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStopFromISR
%ifdef xTimerStopFromISR
%define! ParpxHigherPriorityTaskWoken
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerStopFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStopFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStopFromISR
%-BW_METHOD_END xTimerStopFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriodFromISR
%ifdef xTimerChangePeriodFromISR
%define! ParxTimer
%define! ParxNewPeriod
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriodFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerChangePeriodFromISR(TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerChangePeriodFromISR
%-BW_METHOD_END xTimerChangePeriodFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerResetFromISR
%ifdef xTimerResetFromISR
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerResetFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerResetFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerResetFromISR
%-BW_METHOD_END xTimerResetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTimerGetTimerID
%ifdef pvTimerGetTimerID
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpvTimerGetTimerID.Inc
/*
void* %'ModuleName'%.%pvTimerGetTimerID(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvTimerGetTimerID
%-BW_METHOD_END pvTimerGetTimerID
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerGetTimerDaemonTaskHandle
%ifdef xTimerGetTimerDaemonTaskHandle
%define! RetVal
%include Common\FreeRTOSxTimerGetTimerDaemonTaskHandle.Inc
/*
TaskHandle_t %'ModuleName'%.%xTimerGetTimerDaemonTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerGetTimerDaemonTaskHandle
%-BW_METHOD_END xTimerGetTimerDaemonTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTimerGetTimerName
%ifdef pcTimerGetTimerName
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpcTimerGetTimerName.Inc
/*
char* %'ModuleName'%.%pcTimerGetTimerName(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pcTimerGetTimerName
%-BW_METHOD_END pcTimerGetTimerName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCall
%ifdef xTimerPendFunctionCall
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCall.Inc
/*
BaseType_t %'ModuleName'%.%xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerPendFunctionCall
%-BW_METHOD_END xTimerPendFunctionCall
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCallFromISR
%ifdef xTimerPendFunctionCallFromISR
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCallFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerPendFunctionCallFromISR
%-BW_METHOD_END xTimerPendFunctionCallFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyGive
%ifdef xTaskNotifyGive
%define! ParxTaskToNotify
%define! RetVal
%include Common\FreeRTOSxTaskNotifyGive.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyGive(TaskHandle_t xTaskToNotify)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyGive
%-BW_METHOD_END xTaskNotifyGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN ulTaskNotifyTake
%ifdef ulTaskNotifyTake
%define! ParxClearCountOnExit
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSulTaskNotifyTake.Inc
/*
uint32_t %'ModuleName'%.%ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- ulTaskNotifyTake
%-BW_METHOD_END ulTaskNotifyTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskNotifyGiveFromISR
%ifdef vTaskNotifyGiveFromISR
%define! ParxTaskToNotify
%define! ParpxHigherPriorityTaskWoken
%include Common\FreeRTOSvTaskNotifyGiveFromISR.Inc
/*
void %'ModuleName'%.%vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskNotifyGiveFromISR
%-BW_METHOD_END vTaskNotifyGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotify
%ifdef xTaskNotify
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! RetVal
%include Common\FreeRTOSxTaskNotify.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotify
%-BW_METHOD_END xTaskNotify
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyFromISR
%ifdef xTaskNotifyFromISR
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyFromISR
%-BW_METHOD_END xTaskNotifyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyWait
%ifdef xTaskNotifyWait
%define! ParulBitsToClearOnEntry
%define! ParulBitsToClearOnExit
%define! ParpulNotificationValue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTaskNotifyWait.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyWait
%-BW_METHOD_END xTaskNotifyWait
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%IMPLEMENTATION vApplicationStackOverflowHook
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc
void %vApplicationStackOverflowHook(xTaskHandle pxTask, char *pcTaskName)
{
  /* This will get called if a stack overflow is detected during the context
     switch.  Set configCHECK_FOR_STACK_OVERFLOWS to 2 to also check for stack
     problems within nested interrupts, but only do this for debug purposes as
     it will increase the context switch time. */
  (void)pxTask;
  (void)pcTaskName;
  taskDISABLE_INTERRUPTS();
  /* Write your code here ... */
  for(;;) {}
}

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%IMPLEMENTATION vApplicationTickHook
%include Common\FreeRTOSvApplicationTickHook.Inc
void %vApplicationTickHook(void)
{
  /* Called for every RTOS tick. */
  /* Write your code here ... */
}

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%IMPLEMENTATION vApplicationIdleHook
%include Common\FreeRTOSvApplicationIdleHook.Inc
void %vApplicationIdleHook(void)
{
  /* Called whenever the RTOS is idle (from the IDLE task).
     Here would be a good place to put the CPU into low power mode. */
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08") | (CPUfamily = "ColdFireV1")
#if 0
  /* To put the CPU into lower power WAIT mode:
     - Make sure that in the CPU component the method 'SetWaitMode()' is enabled
     - Enable this code block (change '#if 0' to '#if 1')
   */
    %'ProcessorModule'%.SetWaitMode();
#endif
%elif (CPUfamily = "MCF")
#if 0
  /* To put the ColdFire V2 CPU into low power WAIT mode:
     - In the CPU component, go to 'Properties > Internal peripherals > PowerManagement > Low-power mode'
       - Set 'Low-power stop mode' to 'Enabled'
       - Set 'Low-power mode select' to 'WAIT'
     - Enable this code block (change '#if 0' to '#if 1')
     - Note: if you are using USB then putting the CPU into lower power mode might impact USB communication.
   */
    __asm("stop #0x2000"); /* put CPU into stop mode */
#endif
%endif
  /* Write your code here ... */
}

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%IMPLEMENTATION vApplicationMallocFailedHook
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc
void %vApplicationMallocFailedHook(void)
{
  /* Called if a call to pvPortMalloc() fails because there is insufficient
     free memory available in the FreeRTOS heap.  pvPortMalloc() is called
     internally by FreeRTOS API functions that create tasks, queues, software
     timers, and semaphores.  The size of the FreeRTOS heap is set by the
     configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
  taskDISABLE_INTERRUPTS();
  /* Write your code here ... */
  for(;;) {}
}

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_METHOD_BEGIN vOnPostSleepProcessing
%ifdef vOnPostSleepProcessing
%IMPLEMENTATION vOnPostSleepProcessing
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPostSleepProcessing.Inc
void %vOnPostSleepProcessing(portTickType expectedIdleTicks)
{
  (void)expectedIdleTicks; /* not used (yet?) */
  /* Write your code here ... */
}

%endif %- vOnPostSleepProcessing
%-BW_METHOD_END vOnPostSleepProcessing
%-BW_METHOD_BEGIN vOnPreSleepProcessing
%ifdef vOnPreSleepProcessing
%IMPLEMENTATION vOnPreSleepProcessing
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPreSleepProcessing.Inc
void %vOnPreSleepProcessing(portTickType expectedIdleTicks)
{
  (void)expectedIdleTicks; /* not used */
%if (CPUfamily = "Kinetis")
#if 1
%else
#if 0
%endif
  /* example for Kinetis (enable SetOperationMode() in CPU component): */
  Cpu_SetOperationMode(DOM_WAIT, NULL, NULL);
  /* or to wait for interrupt:
    __asm volatile("dsb");
    __asm volatile("wfi");
    __asm volatile("isb");
  */
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08") | (CPUfamily = "ColdFireV1")
#elif 1
%else
#elif 0
%endif
  /* example for S08/S12/ColdFire V1 (enable SetWaitMode() in CPU): */
  Cpu_SetWaitMode();
%if (CPUfamily = "MCF")
#elif 1
%else
#elif 0
%endif
  /* example for ColdFire V2: */
   __asm("stop #0x2000"); */
#else
  #error "you *must* enter low power mode (wait for interrupt) here!"
#endif
  /* Write your code here ... */
}

%endif %- vOnPreSleepProcessing
%-BW_METHOD_END vOnPreSleepProcessing
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
#if configSYSTICK_USE_LOW_POWER_TIMER
  /* enable clocking for low power timer, otherwise vPortStopTickTimer() will crash */
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_LPTMR0, PDD_ENABLE);
#endif
  vPortStopTickTimer(); /* tick timer shall not run until the RTOS scheduler is started */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
