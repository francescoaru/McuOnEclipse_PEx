<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Bean  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>FSL_USB_-<br />CDC_Device</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="FSL_USB_CDC_Device.html">General Info</a><br />
<a href="FSL_USB_CDC_DeviceApplication Notes.html">Application Notes</a><br />
<a href="FSL_USB_CDC_DeviceEvents.html">Events</a><br />
<i>Methods</i><br />
<a href="FSL_USB_CDC_DeviceProperties.html">Properties</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />

<br /><br /><br />
<center>
<img src="FSL_USB_CDC_Device_b.gif" alt="Bean icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Bean
              
              
              FSL_USB_CDC_Device
            </div>
            <div class="descrtext">Freescale USB Stack (CDC)</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">SW-Communication</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="ClearRxBuffer">
<b>ClearRxBuffer</b></a>
 - Clears the receiver buffer content
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void ClearRxBuffer(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="ClearTxBuffer">
<b>ClearTxBuffer</b></a>
 - Clears the transmit buffer content
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void ClearTxBuffer(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="GetFreeInTxBuf">
<b>GetFreeInTxBuf</b></a>
 - Returns the number of free character in the send buffer
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint16_t GetFreeInTxBuf(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint16_t</i> - Number of free character in the receive buffer.
</li>
</ul><br />
</li>
<li><a name="GetCharsInTxBuf">
<b>GetCharsInTxBuf</b></a>
 - Returns the number of character in the send buffer
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint16_t GetCharsInTxBuf(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint16_t</i> - Number of character in the receive buffer.
</li>
</ul><br />
</li>
<li><a name="GetCharsInRxBuf">
<b>GetCharsInRxBuf</b></a>
 - Returns the number of character in the receive buffer
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint16_t GetCharsInRxBuf(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint16_t</i> - Number of character in the receive buffer.
</li>
</ul><br />
</li>
<li><a name="GetChar">
<b>GetChar</b></a>
 - Receives a character from the USB interface. Function is not blocking if there is no character in the input buffer.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t GetChar(<i>ComponentName_</i>TComData *Chr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Chr: Pointer to <i>ComponentName_</i>TComData</i> - Pointer to where to store the character received</li>
<li><i>Return value:uint8_t</i> - Error code, ERR_OK for success, ERR_RXEMPTY if nothing is in RX buffer.
</li>
</ul><br />
</li>
<li><a name="RecvChar">
<b>RecvChar</b></a>
 - Receives a character from the USB interface. Function is blocking if there is no character in the input buffer.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t RecvChar(<i>ComponentName_</i>TComData *Chr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Chr: Pointer to <i>ComponentName_</i>TComData</i> - Pointer to where to store the character received</li>
<li><i>Return value:uint8_t</i> - Error code, ERR_OK for success, ERR_RXEMPTY if nothing is in RX buffer.
</li>
</ul><br />
</li>
<li><a name="SendChar">
<b>SendChar</b></a>
 - Method to send a character to the USB interface. Method is non-blocking: If the output buffer is full, it tries to send it over USB. If this fails or buffer is still full, the character will be lost. If OnError() event is enabled, the error event will be called in case of error.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t SendChar(<i>ComponentName_</i>TComData Chr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Chr:<i>ComponentName_</i>TComData</i> - Character to send.</li>
<li><i>Return value:uint8_t</i> - Error code. ERR_OK for success and ERR_FAILED otherwise.
</li>
</ul><br />
</li>
<li><a name="SendString">
<b>SendString</b></a>
 - Method to send a string to the USB interface. Method is non-blocking: if string cannot be sent, it will be lost. If OnError() event is enabled, the error event will be called in case of error.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t SendString(<i>ComponentName_</i>TComData *Chr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Chr: Pointer to <i>ComponentName_</i>TComData</i> - Pointer to string to send.</li>
<li><i>Return value:uint8_t</i> - Error code. ERR_OK for success and ERR_FAILED otherwise.
</li>
</ul><br />
</li>
<li><a name="SendBlock">
<b>SendBlock</b></a>
 - Method to send a data block to the USB interface. Method is non-blocking: if data cannot be sent, it will be lost. If OnError() event is enabled, the error event will be called in case of error.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t SendBlock(uint8_t *data, uint16_t dataSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>data: Pointer to uint8_t</i> - Pointer to data to send.</li>
<li><i>dataSize:uint16_t</i> - Size of data in bytes</li>
<li><i>Return value:uint8_t</i> - Error code. ERR_OK for success and ERR_FAILED otherwise.
</li>
</ul><br />
</li>
<li><a name="PutBufferChecked">
<b>PutBufferChecked</b></a>
 - Puts a data block into the output buffer, but does not send it. If there is not enough size available, then ERR_TXFULL is returned, otherwise ERR_OK. The application then needs to call USB_App_Callback() to actually send the buffer.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t PutBufferChecked(uint8_t *buf, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>buf: Pointer to uint8_t</i> - Pointer to buffer to be sent</li>
<li><i>bufsize:uint16_t</i> - Buffer size in bytes</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="App_Callback">
<b>App_Callback</b></a>
 - Method to handle class callbacks from USB
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void App_Callback(uint8_t controller_ID, uint8_t event_type, void *val)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>controller_ID:uint8_t</i> - controller ID</li>
<li><i>event_type:uint8_t</i> - value of the event</li>
<li><i>val:uint8_t</i> - gives the configuration value</li>
</ul><br />
</li>
<li><a name="Notify_Callback">
<b>Notify_Callback</b></a>
 - Method to handle PSTN Sub Class callbacks
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Notify_Callback(uint8_t controller_ID, uint8_t event_type, void *val)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>controller_ID:uint8_t</i> - controller ID</li>
<li><i>event_type:uint8_t</i> - value of the event</li>
<li><i>val:uint8_t</i> - no hint</li>
</ul><br />
</li>
<li><a name="App_Task">
<b>App_Task</b></a>
 - Application task to be called periodically from the main task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t App_Task(uint8_t *txBuf, size_t txBufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>txBuf: Pointer to uint8_t</i> - Pointer to temporary buffer used to transmit data over USB. Should be equal or greater than the endpoint buffer size. Data will be sent in an asynchronous way, so make sure the buffer is *not* on the stack. This buffer must be available until the next transmission.</li>
<li><i>txBufSize:uint8_t</i> - Size of the buffer in bytes</li>
<li><i>Return value:uint8_t</i> - Error code, returns ERR_OK if USB enumeration has been finished, error code otherwise.
</li>
</ul><br />
</li>
<li><a name="Deinit">
<b>Deinit</b></a>
 - Deinitializes the driver
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t Deinit(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Init">
<b>Init</b></a>
 - Initializes the driver
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t Init(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
