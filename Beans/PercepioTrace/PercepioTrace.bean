<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>PercepioTrace</Name>
    <Description>Percepio FreeRTOS Trace</Description>
    <Author>Erich Styger</Author>
    <Version>01.070</Version>
    <Icon>irc</Icon>
    <TypesFiles>PE,PercepioTrace\PercepioTrace</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <BW_HelpType>Basic</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>3</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright>(c) Copyright Percepio AB, 2013-2015\nhttp      : www.percepio.se\nmail      : info@percepio.com\nProcessor Expert port: Erich Styger, 2013-2015</Copyright>
    <Category>Operating Systems</Category>
    <DemoDriver>no</DemoDriver>
    <Shortcut>PTRC</Shortcut>
    <BeanLevel>High</BeanLevel>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>RTOS+Trace Version</Name>
        <Symbol>RTOSplusTraceVersion</Symbol>
        <Hint>Identifies the RTOS+Trace version used from Percepio AB</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>V3.0.2</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Streaming with RTT</Name>
        <Symbol>StreamingTraceWithRTT</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>EXPERIMENTAL: using a different trace library which streams using Segger RTT</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TStrgItem>
              <Name>Streaming Recorder Version</Name>
              <Symbol>StreamingRecorderVersion</Symbol>
              <Hint>Identifies the RTOS+Trace version used from Percepio AB</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>V3.0.2</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Symbol Table Slots</Name>
              <Symbol>SymbolTableSlots</Symbol>
              <Hint>SYMBOL_TABLE_SLOTS: The maximum number of symbols names that can be stored. This includes task names, named ISR's, named kernel objects and user event channels.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>30</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Symbol Max Length</Name>
              <Symbol>SymbolMaxLength</Symbol>
              <Hint>SYMBOL_MAX_LENGTH: The maximum length of symbol names.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>24</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Object Data Slots</Name>
              <Symbol>ObjectDataSlots</Symbol>
              <Hint>OBJECT_DATA_SLOTS: The maximum number of object data entries (used for task priorities) that can be stored at the same time. Must be sufficient for all tasks, otherwise there will be warnings (as User Events) from TzCtrl task, that monitors this.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>20</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Ctrl Task Priority</Name>
              <Symbol>CtrlTaskPrioStr</Symbol>
              <Hint>TRC_CTRL_TASK_PRIORITY: Priority of the Ctrl task which streams the data. Priority can be rather low, except if your system load is very high, then use (configMAX_PRIORITIES-1)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>1</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Ctrl Task Stack Size</Name>
              <Symbol>CtrlTaskStackSize</Symbol>
              <Hint>CTRL_TASK_STACK_SIZE: The stack size of the Ctrl task, that receive commands.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>configMINIMAL_STACK_SIZE</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Segger RTT</Name>
              <Symbol>SeggerRTT</Symbol>
              <TypeSpec>PercepioTrace\SeggerRTT</TypeSpec>
              <Hint>Interface to Segger RTT</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Up Buffer Index</Name>
              <Symbol>RTTUpBufferIndex</Symbol>
              <Hint>RTT_UP_BUFFER_INDEX: Defines the RTT buffer to use for writing the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>0</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Up Buffer Size</Name>
              <Symbol>TraceRTTUpBufferSize</Symbol>
              <Hint>Up Buffer Size (default 1024), only applicable for buffer index &gt; 0</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>1024</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Down Buffer Index</Name>
              <Symbol>RTTDownBufferIndex</Symbol>
              <Hint>RTT_DOWN_BUFFER_INDEX: Defines the RTT buffer to use for reading the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>0</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Down Buffer Size</Name>
              <Symbol>TraceRTTDownBufferSize</Symbol>
              <Hint>Down Buffer Size (default 32), only applicable for buffer index &gt; 0</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Utility</Name>
        <Symbol>Utility</Symbol>
        <TypeSpec>Utility_I</TypeSpec>
        <Hint>Interface to utility functions</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Scheduling only</Name>
        <Symbol>TraceSchedulingOnly</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This defines TRACE_SCHEDULING_ONLY in trcConfig.h\n
When defined (set to 'yes', disables all events except scheduling. Useful for Free Edition users.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Description string</Name>
        <Symbol>TraceDescriptionString</Symbol>
        <Hint>This sets TRACE_DESCRIPTION in trcConfig.h\n
This string is stored in the trace and displayed in FreeRTOS+Trace. Can be used to store, e.g., system version or build date.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>FreeRTOS+Trace</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>63</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Description max length</Name>
        <Symbol>TraceDescriptionMaxLength</Symbol>
        <Hint>Sets the TRACE_DESCRIPTION_MAX_LENGTH macro. Generic system information string, presented in the tool. Note that this is also used for storing any internal error messages from the recorder, so do not make TRACE_DESCRIPTION_MAX_LENGTH too small. 80 is recommended.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>80</DefaultValue>
        <MinValue>8</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Events</Name>
        <Symbol>EventsGroup</Symbol>
        <Hint>Used to configure which events are created</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TGrupItem>
              <Name>Kernel Service Calls</Name>
              <Symbol>KernelServiceCalls</Symbol>
              <Hint>Group which kernel service calls are generated</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description/>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TGrupItem>
                    <Name>Task</Name>
                    <Symbol>TaskGroup</Symbol>
                    <Hint>Configuration which Task events are generated</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description/>
                    <Expanded>Yes</Expanded>
                    <Children>
                      <GrupItem>
                        <TBoolItem>
                          <Name>vTaskDelay</Name>
                          <Symbol>vTaskDelayEventGenerated</Symbol>
                          <TypeSpec>typeYesNo</TypeSpec>
                          <Hint>If event for vTaskDelay() shall be generated.</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>false</EditLine>
                          <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                          <DefaultIndex>0</DefaultIndex>
                          <TextValueIndex>false</TextValueIndex>
                          <RuntimeProperty>false</RuntimeProperty>
                          <CanDelete>false</CanDelete>
                          <IconPopup>false</IconPopup>
                          <DefaultValue>true</DefaultValue>
                          <Popup>false</Popup>
                        </TBoolItem>
                      </GrupItem>
                      <GrupItem>
                        <TBoolItem>
                          <Name>vTaskDelayUntil</Name>
                          <Symbol>vTaskDelayUntilEventGenerated</Symbol>
                          <TypeSpec>typeYesNo</TypeSpec>
                          <Hint>If event for vTaskDelayUntil() shall be generated.</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>false</EditLine>
                          <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                          <DefaultIndex>0</DefaultIndex>
                          <TextValueIndex>false</TextValueIndex>
                          <RuntimeProperty>false</RuntimeProperty>
                          <CanDelete>false</CanDelete>
                          <IconPopup>false</IconPopup>
                          <DefaultValue>true</DefaultValue>
                          <Popup>false</Popup>
                        </TBoolItem>
                      </GrupItem>
                    </Children>
                  </TGrupItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include user events</Name>
        <Symbol>IncludeUserEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_USER_EVENTS in trcConfig.h\n
If this is zero (0) the code for creating User Events is excluded to reduce code size. User Events are application-generated events, like "printf" but for the trace log instead of console output. User Events are much faster than a printf and can therefore be used in timing critical code. See vTraceUserEvent() and vTracePrintF() in trcUser.h.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include ISR tracing</Name>
        <Symbol>IncludeISRTracing</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_ISR_TRACING in trcConfig.h\n
If this is zero (0), the code for recording Interrupt Service Routines is excluded to reduce code size. Note, recording ISRs require that you insert calls to vTraceStoreISRBegin and vTraceStoreISREnd in your interrupt handlers. There is no automatic recording of ISRs like for task scheduling, since FreeRTOS does not have a central interrupt dispatcher.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Max ISR Nesting</Name>
        <Symbol>TraceMaxISRNesting</Symbol>
        <Hint>Defines the maxium level of ISR nesting</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>16</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include object delete events</Name>
        <Symbol>IncludeObjectDelete</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_OBJECT_DELETE in trcConfig.h\n
This must be enabled (1) if tasks, queues or other traced kernel objects are deleted at runtime, e.g., using vTaskDelete or vQueueDelete. If no deletes are made, this can be set to 0 in order to exclude the delete-handling code. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include new time events</Name>
        <Symbol>IncludeNewTimeEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_NEW_TIME_EVENTS in trcConfig.h\n
This must be enabled (1) if it shall be recorded whenever the os clock is increased.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include ready events</Name>
        <Symbol>IncludeReadyEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_READY_EVENTS in trcConfig.h\n
If this is set to 'no', the code for recording Ready events is excluded. Note, this will make it impossible to calculate the correct response times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include memory manager events</Name>
        <Symbol>IncludeMemManageEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_MEMMANG_EVENTS in trcConfig.h\n
This must be enabled (1) if memory allocation and deallocatinon have to be traced.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Heap Size below 16M</Name>
        <Symbol>HeapSizeBelow16M</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets HEAP_SIZE_BELOW_16M in trcConfig.h\n
* HEAP_SIZE_BELOW_16M\n
*\n
* An integer constant that can be used to reduce the buffer usage of memory\n
* allocation events (malloc/free). This value should be 1 if the heap size is \n
* below 16 MB (2^24 byte), and you can live with addresses truncated to the \n
* lower 24 bit. Otherwise set it to 0 to get the full 32-bit addresses.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Trace Data Allocation</Name>
        <Symbol>TraceDataAllocation</Symbol>
        <TypeSpec>typeTraceDataAllocation</TypeSpec>
        <Hint>This defines the macro TRACE_DATA_ALLOCATION. This defines how to allocate the recorder data structure, i.e., using a  static declaration or using a dynamic allocation in runtime (malloc). Should be one of these two options:\n
 - TRACE_DATA_ALLOCATION_STATIC (default)\n
 - TRACE_DATA_ALLOCATION_DYNAMIC\n
Using static allocation has the benefits of compile-time errors if the buffer is too large (too large constants in trcConfig.h) and no need to call the initialization routine (xTraceInitTraceData). Using dynamic allocation may give more flexibility in some cases.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Recorder store mode</Name>
        <Symbol>RecorderStoreMode</Symbol>
        <TypeSpec>typeRecorderStoreMode</TypeSpec>
        <Hint>This sets RECORDER_STORE_MODE in trcConfig.h\n
With RECORDER_STORE_MODE set to STORE_MODE_RING_BUFFER, the events are stored in a ring buffer, i.e., where the oldest events are overwritten when the buffer becomes full. This allows you to get the last events leading up to an interesting state, e.g., an error, without having a large trace buffer for string the whole run since startup. In this mode, the recorder can run "forever" as the buffer never gets full, i.e., in the sense that it always has room for more events.\n
\n
To fetch the trace in mode STORE_MODE_RING_BUFFER, you need to first halt the system using your debugger and then do a RAM dump, or to explicitly stop the recorder using vTraceStop() and then store/upload the trace data using a FreeRTOS task that you need to provide yourself. The trace data is found in the struct RecorderData, initialized in trcBase.c.\n
\n
Note that, if you upload the trace using a RAM dump, i.e., when the system is halted on a breakpoint or by a debugger command, there is no need to stop the recorder first.\n
\n
When RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recording is stopped when the buffer becomes full. When the recorder stops itself this way vTracePortEnd() is called which allows for custom actions, such as triggering a task that stores the trace buffer, i.e., in case taking a RAM dump using an on-chip debugger is not possible. In the Windows port, vTracePortEnd saves the trace to file directly, but this is not recommended in a real-time system since the scheduler is blocked during the processing of vTracePortEnd.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use implicit IFE rules</Name>
        <Symbol>UseImplicitIFErules</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets USE_IMPLICIT_IFE_RULES in trcConfig.h\n
### Instance Finish Events (IFE) ###\n
\n
For tasks with "infinite" main loops (non-terminating tasks), the concept of a task instance has no clear definition, it is an application-specific thing. FreeRTOS+Trace allows you to define Instance Finish Events (IFEs), which marks the point when a task instance ends. The IFE is a blocking kernel call, typically in the main loop of a task which typically reads a message queue, waits for a semaphore or performs an explicit delay.\n
\n
If USE_IMPLICIT_IFE_RULES is one (1), the following FreeRTOS kernel calls are considered by default to be IFEs (Implicit IFEs):\n
 - vTaskDelay\n
 - vTaskDelayUntil\n
 - vTaskSuspend\n
 - xQueueReceive\n
 - xSemaphoreTake\n
\n
However, Implicit IFEs only applies to blocking kernel calls. If an xQueueReceive reads a message without blocking, it does not create a new instance since no blocking occurred.\n
\n
Moreover, the actual IFE might sometimes be another blocking call such as xQueueSend or xSemaphoreGive. We therefore allow for user-defined explicit IFEs by calling\n
       vTraceTaskInstanceIsFinished()\n
right before the kernel call considered as IFE. This does not create an additional event but instead stores the service code and object handle of the IFE call as properties of the task.\n
\n
If using Explicit IFEs and the task also calls an Implicit IFE like vTaskDelay, this may result in additional incorrect task instances. This is solved by disabling the Implicit IFEs for the task, by adding a call to\n
       vTraceTaskSkipDefaultInstanceFinishedEvents()\n
in the very beginning of that task. This allows you to combine Explicit IFEs for some tasks with Implicit IFEs for the rest of the tasks, if USE_IMPLICIT_IFE_RULES is 1.\n
\n
By setting USE_IMPLICIT_IFE_RULES to zero (0), the implicit IFEs are disabled for all tasks. Tasks will then be considered to have a single instance only, covering all execution fragments, unless you define an explicit IFE in the task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use 16bit Object Handles</Name>
        <Symbol>Use16bitObjectHandles</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets USE_16BIT_OBJECT_HANDLES in trcConfig.h\n
 * Macro which should be defined as either zero (0) or one (1).\n
 * Default is 0.\n
 *\n
 * If set to 0 (zero), the recorder uses 8-bit handles to identify kernel \n
 * objects such as tasks and queues. This limits the supported number of\n
 * concurrently active objects to 255 of each type (object class).\n
 *\n
 * If set to 1 (one), the recorder uses 16-bit handles to identify kernel \n
 * objects such as tasks and queues. This limits the supported number of\n
 * concurrent objects to 65535 of each type (object class). However, since the\n
 * object property table is limited to 64 KB, the practical limit is about\n
 * 3000 objects in total. \n
 * \n
 * NOTE: An object with a high ID (&gt; 255) will generate an extra event \n
 * (= 4 byte) in the event buffer. \n
 * \n
 * NOTE: Some internal tables in the recorder gets larger when using 16-bit \n
 * handles. The additional RAM usage is 5-10 byte plus 1 byte per kernel object\n
 *, i.e., task, queue, semaphore, mutex, etc.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include event stats</Name>
        <Symbol>IncludeEventStats</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_EVENT_STATS in trcConfig.h\n
If enabled (1), the recorder will count each type of event, in order to give an immediate picture (in a console print), regarding what events that is using significant buffer space. In the Windows emulation port, vTracePortEnd() will print this info when the recorder is stopped. This is not recommended in a real-time system, as vTracePortEnd is called from the kernel and blocks it until vTracePortEnd returns.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Event Count Size</Name>
        <Symbol>EventCountSize</Symbol>
        <Hint>If 'Include event stats' is enabled, then this defines the size of the gloabal event count array. This setting defines the EVENT_COUNT_SIZE macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>256</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Float support</Name>
        <Symbol>floatingPointForvTracePrintF</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If floating point is supported for vTracePrintF()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Event buffer size</Name>
        <Symbol>EventBufferSize</Symbol>
        <Hint>This sets EVENT_BUFFER_SIZE in trcConfig.h\n
Macro which should be defined as an integer value.\n
This defines the capacity of the event buffer, i.e., the number of records it may store. An event typically use one record (4 byte), but there are exceptions:\n
In some cases, an XTS event is added if the time since the last event is longer that allowed by the current event's timestamp field. Such events thus use two records. vTracePrintF use a variable number of data records following the event, holding the data arguments. \n
If RECORDER_STORE_MODE is STORE_MODE_RING_BUFFER, the recorder will wrap around to index 0 when reached EVENT_BUFFER_SIZE. If RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recorder is instead stopped (see RECORDER_STORE_MODE).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>1200</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Symbol table size</Name>
        <Symbol>SymbolTableSize</Symbol>
        <Hint>This sets SYMBOL_TABLE_SIZE in trcConfig.h\n
Macro which should be defined as an integer value.\n
This defines the capacity of the symbol table, in bytes. This symbol table stores User Events labels and names of deleted tasks, queues, or other kernel objects. Note that the names of active objects not stored here but in the Object Table. Thus, if you don't use User Events or delete any kernel objects you set this to zero (0) to minimize RAM usage.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>400</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of tasks</Name>
        <Symbol>NTask</Symbol>
        <Hint>This sets NTask in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>10</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of ISR</Name>
        <Symbol>NISR</Symbol>
        <Hint>This sets NISR in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of queue</Name>
        <Symbol>NQueue</Symbol>
        <Hint>This sets NQueue in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>3</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of semaphore</Name>
        <Symbol>NSemaphore</Symbol>
        <Hint>This sets NSemaphore in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of mutex</Name>
        <Symbol>NMutex</Symbol>
        <Hint>This sets NMutex in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of Timer</Name>
        <Symbol>NTimer</Symbol>
        <Hint>This sets the NTimer define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>2</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of Event Groups</Name>
        <Symbol>NEventGroup</Symbol>
        <Hint>This sets the NEventGroup macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>2</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Name length for task</Name>
        <Symbol>NameLenTaskStr</Symbol>
        <Hint>This sets NameLenTask in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>configMAX_TASK_NAME_LEN</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for ISR</Name>
        <Symbol>NameLenISR</Symbol>
        <Hint>This sets NameLenISR in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>10</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for queue</Name>
        <Symbol>NameLenQueue</Symbol>
        <Hint>This sets NameLenQueue in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for semaphore</Name>
        <Symbol>NameLenSemaphore</Symbol>
        <Hint>This sets NameLenSemaphore in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for mutex</Name>
        <Symbol>NameLenMutex</Symbol>
        <Hint>This sets NameLenMutex in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for timer</Name>
        <Symbol>NameLenTimer</Symbol>
        <Hint>Sets NameLenTimer define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for event group</Name>
        <Symbol>NameLenEventGroup</Symbol>
        <Hint>Sets NameLenEventGroup define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>uiTraceStart</Name>
        <Symbol>uiTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Starts the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>returns 1 if trace has been started, 0 otherwise.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStop</Name>
        <Symbol>vTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Stops the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceClear</Name>
        <Symbol>vTraceClear</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uiTraceGetTraceBufferSize</Name>
        <Symbol>uiTraceGetTraceBufferSize</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gets the size of the recorder data structure. For use together with vTraceGetTraceBuffer if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Size of the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceGetTraceBuffer</Name>
        <Symbol>vTraceGetTraceBuffer</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return a pointer to the recorder data structure. Use this together with uiTraceGetTraceBufferSize if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Pointer to the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetTimerFrequency</Name>
        <Symbol>vTraceSetTimerFrequency</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Use this to define the frequency of the timer/counter used for timestamping (in Hz)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>frequency</ParName>
          <ParType>32bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>frequency</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(dword frequency)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceOpenLabel</Name>
        <Symbol>xTraceOpenLabel</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Open/create symbol to use as user event handle for related user events (conceptually like a file handle)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>traceLabel</ReturnType>
        <RetHint>trace label</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>label</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to label</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>traceLabel #M#_#C#(char *label)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceUserEvent</Name>
        <Symbol>vTraceUserEvent</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Simple user event - store a label, created using xTraceOpenLabel</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>eventLabel</ParName>
          <ParType>traceLabel</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label for the user event</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceLabel eventLabel)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTracePrintF</Name>
        <Symbol>vTracePrintF</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Advanced user event - like printf (but limited formatting support - will improve)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>eventLabel</ParName>
          <ParType>traceLabel</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label</ParHint>
        </Parameter>
        <Parameter>
          <ParName>formatStr</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to format string</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>open parameter list</ParHint>
          <ParUserDeclaration>...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceLabel eventLabel, char *formatStr, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetQueueName</Name>
        <Symbol>vTraceSetQueueName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>queue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the queue</ParHint>
          <ParUserDeclaration>void *queue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *queue, char *name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetISRProperties</Name>
        <Symbol>vTraceSetISRProperties</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers an Interrupt Service Routine in the recorder library, This must be called before using vTraceStoreISRBegin to store ISR events. This is typically called in the startup of the system, before the scheduler is started. Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>handle</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>handle to be used</ParHint>
          <ParUserDeclaration>objectHandleType handle</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Parameter>
          <ParName>prioritiy</ParName>
          <ParType>char</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>priority</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(objectHandleType handle, char *name, char prioritiy)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISRBegin</Name>
        <Symbol>vTraceStoreISRBegin</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the beginning of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>id</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>ID of the ISR</ParHint>
          <ParUserDeclaration>objectHandleType id</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(objectHandleType id)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISREnd</Name>
        <Symbol>vTraceStoreISREnd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the end of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pendingISR</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The parameter pendingISR indicates if the interrupt has requested a task-switch (= 1) or if the interrupt returns to the earlier context (= 0)</ParHint>
          <ParUserDeclaration>int pendingISR</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int pendingISR)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskSkipDefaultInstanceFinishedEvents</Name>
        <Symbol>vTraceTaskSkipDefaultInstanceFinishedEvents</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This is useful if there are implicit Instance Finish Events, such as vTaskDelayUntil or xQueueReceive, in a task where an explicit Instance Finish Event has been defined. This function tells the recorder that only the explicitly defined functions, using vTraceTaskInstanceIsFinished, should be treated as Instance Finish Events for this task. The implicit Instance Finish Events are thus disregarded for this task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskInstanceIsFinished</Name>
        <Symbol>vTraceTaskInstanceIsFinished</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This defines an explicit Instance Finish Event for the current task. It tells the recorder that the current instance of this task is finished at the next kernel call of the task, e.g., a taskDelay or a queue receive. This function should be called right before the api function call considered to be the end of the task instance, i.e., the Instance Finish Event.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceExcludeTaskFromSchedulingTrace</Name>
        <Symbol>vTraceExcludeTaskFromSchedulingTrace</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Excludes a task from the recording using a flag in the Object Property Table. This can be useful if some irrelevant task is very frequent and is "eating up the buffer". This should be called the task has been created, but  before starting the FreeRTOS scheduler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>name</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>name of the task</ParHint>
          <ParUserDeclaration>const char* name</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const char* name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceInitTraceData</Name>
        <Symbol>vTraceInitTraceData</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Allocates, if necessary, and initializes the recorder data structure, based on the settings.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Pointer to trace data (RecorderDataType*)</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vGetGDBDumpCommand</Name>
        <Symbol>vGetGDBDumpCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gets the gdb command to dump the trace data to a file. Useful for copy-pasting it to the gdb console.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>buf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer for the command. Make it large enoug (about 64 bytes)</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of the buffer</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fileName</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the file name string, e.g. "C:\\tmp\\trace.dump"</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t *buf, uint16_t bufSize, uint8_t *fileName)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetStopHook</Name>
        <Symbol>vTraceSetStopHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets a function to be called when the recorder is stopped.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>stopHookFunction</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
          <ParUserDeclaration>TRACE_STOP_HOOK stopHookFunction</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(TRACE_STOP_HOOK stopHookFunction)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceGetLastError</Name>
        <Symbol>xTraceGetLastError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gives the last error message, if any. NULL if no error message is stored. Any error message is also presented when opening a trace file.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>Error message</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceClearError</Name>
        <Symbol>vTraceClearError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Removes any previous error message generated by recorder calling vTraceError. By calling this function, it may be possible to start/restart the trace despite errors in the recorder, but there is no guarantee that the trace recorder will work correctly in that case, depending on the type of error.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>resetErrorMessage</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>parameter is not used</ParHint>
          <ParUserDeclaration>int resetErrorMessage</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(int resetErrorMessage)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskInstanceFinish</Name>
        <Symbol>vTraceTaskInstanceFinish</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Marks the current task instance as finished on the next kernel call.\n
If that kernel call is blocking, the instance ends after the blocking event\n
and the corresponding return event is then the start of the next instance.\n
If the kernel call is not blocking, the viewer instead splits the current\n
fragment right before the kernel call, which makes this call the first event\n
of the next instance.\n
See also USE_IMPLICIT_IFE_RULES in trcConfig.h\n
 Example:\n
	while(1)\n
	{\n
        	xQueueReceive(CommandQueue, &amp;command, timeoutDuration);\n
		processCommand(command);\n
                 vTraceInstanceFinish();\n
}</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskInstanceFinishDirect</Name>
        <Symbol>vTraceTaskInstanceFinishDirect</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Marks the current task instance as finished at this very instant.\n
This makes the viewer to splits the current fragment at this point and begin\n
a new actor instance.\n
See also USE_IMPLICIT_IFE_RULES in trcConfig.h\n
Example:\n
		This example will generate two instances for each loop iteration.\n
		The first instance ends at vTraceInstanceFinishDirect(), while the second\n
      instance ends at the next xQueueReceive call.\n
\n
		while (1)\n
		{\n
          xQueueReceive(CommandQueue, &amp;command, timeoutDuration);\n
			ProcessCommand(command);\n
			vTraceInstanceFinishDirect();\n
			DoSometingElse();\n
          vTraceInstanceFinish();\n
      }</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this component are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStop</Name>
        <Symbol>OnTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called if the library calls vTraceStop(). Useful to dump the trace if 'stop when recorder is full' mode is selected.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStop procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStart</Name>
        <Symbol>OnTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called when vTraceStart() gets called.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStart procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceWrap</Name>
        <Symbol>OnTraceWrap</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called for trace ring buffer wrap around. This gives the application a chance to dump the trace buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceWrap procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
